# 技术归纳



## 数据结构

### 栈和堆

1. 什么是栈和堆

   - 栈(stack)：栈会自动分配内存空间，会自动释放，存放基本类型，简单的数据段，占据固定大小的空间。

   基本类型：String，Number，Boolean，Null，Undefined

   - 堆(heap)：动态分配的内存，大小不定也不会自动释放，存放引用类型，指那些可能由多个值构成的对象，保存在堆内存中，包含引用类型的变量，实际上保存的不是变量本身，而是指向该对象的指针。

     引用类型：Function，Array，Object.

2. 两者区别区

   - 栈：所有在方法中定义的变量都是放在栈内存中，随着方法的执行结束，这个方法的内存栈也自然销毁。

     优点：存取速度比堆快，仅次于直接位于CPU中的寄存器，数据可以共享；

     缺点：存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。

   - 堆：堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用(参数传递)。创建对象是为了反复利用，这个对象将被保存到运行时数据区。

​		栈内赋值(a=[],b=a)都是变量在栈中对堆地址引用，当a内容改变时，b也会跟着改变，这就是**浅拷贝**

​		当栈内赋值的同时，也为赋值对象b在堆中创建一个新的内存地址，那么当a改变时，b则因为引用堆地址不同而不变，这就是**深拷贝**

3.	溢出
如果想要堆溢出，比较简单，可以循环创建对象或大的对象；
如果想要栈溢出，可以<u>**递归调用**</u>方法，这样随着栈深度的增加，JVM（虚拟机）维持着一条长长的方法调用轨迹，直到内存不够分配，产生栈溢出。

JavaScript堆不需要程序代码来显示地释放，因为堆是由自动的垃圾回收来负责的，每种浏览器中的JavaScript解释引擎有不同的自动回收方式，但一个最基本的原则是：如果栈中不存在对堆中某个对象的引用，那么就认为该对象已经不再需要，在垃圾回收时就会清除该对象占用的内存空间。因此，在不需要时应该将对对象的引用释放掉（解除引用），以利于垃圾回收，这样就可以提高程序的性能。释放对对象的引用最常用的方法就是为其赋值为null，这种做法适用于大多数全局变量和全局对象的属性。局部变量会在他们离开执行环境时自动被解除引用。

注意：解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。

4.	关于垃圾回收机制
javascript的解析器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。

```javascript
var a = "hello world";
var b = "world";
var a = b;
// 这时，会释放掉“hello world”，释放内存以便再引用
```







## 算法基础



### 二分查找法



### 冒泡排序法









## 前端基础

### CSS

#### CSS样式（选择器）的优先级

1. 第一优先级：无条件优先的属性只需要在属性后面使用!important。它会覆盖页面内任何位置定义的元素样式。（ie6支持上有些bug）。
2. 第一等：内联样式，如：style="color:red;"，权值为1000.（该方法会造成css难以管理，所以不推荐使用）
3. 第二等：ID选择器，如：#header，权值为0100.
4. 第三等：类选择器、如：.bar， 权值为0010.
5. 第四等：类型（标签）选择器和伪元素选择器，如：div ::first-line 权值为0001.
6. 通配符，子选择器，相邻选择器等。如*，>,+, 权值为0000.
7. 继承的样式没有权值。

**CSS选择器的优先级：!important > 行内样式 > ID选择器 > 类选择器 > 标签选择器 > 其他**



#### css实现元素居中

1. 父元素设置display:flex,子元素 margin: auto
2. 利用定位
3. 定位配合css3位移
4. 弹性盒模型
5. 网格布局Grid
6. tabel-cell实现垂直居中



#### rem

1、rem的大小是根据html根目录下的字体大小进行计算的。
2、当我们改变根目录下的字体大小的时候，下面字体都改变。
3、rem不仅可以设置字体的大小，也可以设置元素宽、高等属性。

#### em

em的特点：
1、字体大小是根据父元素字体大小设置的



#### CSS中颜色

**在CSS中为元素分配某种颜色的方法有哪些**

1、十六进制颜色码：
十六进制颜色码就是在软件中设定颜色值的代码。通过一个以“#”开头的6位十六进制数值表示一种颜色。6位数字分为3组，每组两位，依次表示红、绿、蓝三种颜色的强度。

2、RGB颜色模式：颜色由表明红色，绿色，和蓝色各成分强度的三个数值表示。从极小值0到最大值255，当所有颜色,都在最低值被显示的颜色将是黑色，当所有颜色都在他们的最大值被显示的颜色将是白色。
3、HSL标记：设计师和美术师通常更喜欢使用HSL（色相/饱和度/亮度）颜色方法进行工作。在Web上，使用HSL功能符号表示HSL颜色。HSL（）CSS函数在用法上与RGB（）函数非常相似。



#### visibility与display

{visibility：hidden}和{display：none}有什么区别？

display:none 表示标签根本不会出现在页面上（尽管您仍然可以通过DOM与之交互）。与其他标签之间将没有分配空间。
visibility:hidden 表示该标签不可见，但在页面上为其分配了空间。标签已呈现，只是在页面上看不到

#### CSS选择器

**CSS选择器（符）有哪些？**

（1）id选择器（#myld）。

（2）类选择器（ .my ClassName）。

（3）标签选择器（div,p,h1）

（4）相邻选择器（h1+p）

（5）子选择器（ul>li）

（6）后代选择器（li a）

（7）通配符选择器（*）

（8）属性选择器（ button[disabled="true"]）。

（9）伪类选择器（ a:hover、 li:nth- child）表示一种状态。

（10）伪元素选择器（li:before、“：after”、“：first- letter”、“：first-line”、“；selecton”）表示文档某个部分的表现



#### CSS继承

**CSS的哪些样式可以继承？哪些不可以继承？**

可继承的样式有font- size font-family color, UL LI DL DD DT。

不可继承的样式有 border、 padding, margin, width、 height。



### Javascrpit基础知识点





#### JS的运行机制

1. js单线程

JavaScript语言的一大特点就是单线程，即同一时间只能做一件事情。

2. js事件循环

js代码执行过程中会有很多任务，这些任务总的分成两类：

同步任务

异步任务

需要注意的是除了同步任务和异步任务，任务还可以更加细分为macrotask(宏任务)和microtask(微任务)，js引擎会优先执行微任务

微任务包括了 promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。

宏任务包括了 script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲
染等。
首先js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。

在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务

当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。

任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。

当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。

```javascript
setTimeout(function() {
  console.log(1)
}, 0);
new Promise(function(resolve, reject) {
  console.log(2);
  resolve()
}).then(function() {
  console.log(3)
});
process.nextTick(function () {
  console.log(4)
})
console.log(5)

/*
第一轮：主线程开始执行，
遇到setTimeout，将setTimeout的回调函数丢到宏任务队列中，在往下执行new Promise立即执行，输出2
then的回调函数丢到微任务队列中，再继续执行，遇到process.nextTick，同样将回调函数扔到为任务队列，再继续执行，输出5，
当所有同步任务执行完成后看有没有可以执行的微任务，发现有then函数和nextTick两个微任务，先执行哪个呢？
process.nextTick指定的异步任务总是发生在所有异步任务之前，因此先执行process.nextTick输出4
然后执行then函数输出3
第一轮执行结束。

第二轮：从宏任务队列开始，发现setTimeout回调，输出1执行完毕，
因此结果是25431
*/
```

> JS延迟加载的方式
> JavaScript 是单线程（js不走完下面不会走是因为同步）会阻塞DOM的解析，因此也就会阻塞DOM的加载。所以有时候我们希望延迟JS的加载来提高页面的加载速度。

1.把JS放在页面的最底部

2.script标签的defer属性：脚本会立即下载但延迟到整个页面加载完毕再执行。该属性对于内联脚本无作用 (即没有 「src」 属性的脚本）。

3.是在外部JS加载完成后，浏览器空闲时，Load事件触发前执行，标记为async的脚本并不保证按照指定他们的先后顺序执行， 该属性对于内联脚本无作用 (即没有 「src」 属性的脚本）。

4.动态创建script标签，监听dom加载完毕再引入js文件

> 宏任务和微任务
> js中的一个机制，就是遇到宏任务，先将宏任务放入eventqueue，然后在执行微任务。

宏任务：setTimeout,setInterval,Ajax,DOM事件

微任务：Promise async/await

想明白这个机制 就要理解js单线程。因为JS是单线程语言，只能同时做一件事儿。js任务需要排队顺序执行，如果一个任务时间过长，后边的任务也会等着。假如，我们在请求一个网址时，图片加载很慢，网页总不能一直卡不出来，

这个时候就可以用异步来解决了，异步的特点不会阻塞代码的执行 ,解决了单线程等待的这个问题

在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务

异步和单线程是相辅相成的，js是一门单线程语言，所以需要异步来辅助。





#### 数据类型【8种】

**Number、String、Boolean、undefined、object、Null、Symbol、bigInt（谷歌定义的，一般不算内）**

【Object是个大类，function函数、array数组、date日期...等都归属于Object】

判断数据类型

1. **typeof**

2. **instanceof**

3. **Object.prototype.toString.call()**

   `Object.prototype.toString.call(val) === '[object Object]' // true 代表为对象`

   `Object.prototype.toString.call(val) === '[object Array]' // true 代表为数组`

   *[object Function]*、*[object Date]*、*[object RegExp]*

4. **Object.getPrototypeOf()**

   `Object.getPrototypeOf(val) === Object.prototype // true 代表为对象`

   `Object.getPrototypeOf(val) === Array.prototype *// true 代表为数组*`

5. **constructor**

6. **toString**

7. **Array.isArray() **

   `Array.isArray(val) // true 代表为数组`

   ```javascript
   function typeOf(obj){
   	return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase()
   }
   
   typeOf([])
   ```

   

#### 对象

扩展运算符： 扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。

枚举属性for in： 循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性），自身属性或者来自原型对象上的继承属性都可以被枚举出来。

Object.create()：创建一个对象（const obj = Object.create({a:1}, {b: {value: 2}})）

Object.assign()： 将所有可枚举属性的值从一个或多个源对象分配到目标对象并返回目标对象,常用来合并对象。 Object.assign(target, …sources)。 参数解析： target—>目标对象，source—>源对象，返回值是target，即目标对象。

Object.keys(obj)： 返回obj对象所有的可枚举的自有属性的名称组成的数组，不包含继承属性。

Object.values()： 返回一个给定对象自身的所有可枚举属性值的数组

Object.entries()： 返回一个给定对象自身可枚举属性的键值对组成的数组

Object.freeze()： 可以冻结一个对象，冻结后不能做任何操作。

hasOwnProperty()： 返回一个布尔值，用于检测这个属性是否是对象本身属性，而不是原型对象上的属性。obj.hasOwnProperty(‘name’))

Object.getOwnPropertyNames(obj)： 返回一个自身所有属性(可枚举和不可枚举属性)名称组成的字符串数组,但是不含 Symbol 属性。

Object.getOwnPropertySymbols(obj)： 返回一个数组，包含对象自身的所有 Symbol 属性的键名。









#### 数组

1. push() 将一个或多个元素添加到数组的末尾，并返回该数组的新长度。此方法修改原有数组。

  ```
  var arr = ['a','b','c'];
  var ele = arr.push('d');
  // ele结果为: 4;
  // arr数组被修改: ['a','b','c','d'];
  
  ```

  

2. pop()，从数组中删除最后一个元素，并返回该元素的值。如果数组为空，则返回undefined。此方法修改原有数组。

  ```
  var arr = ['a','b','c','d'];
  var ele = arr.pop();
  // ele结果为: 'd';
  // arr数组被修改: ['a','b','c'];
  
  ```

  

3. shift()，从数组中删除第一个元素，并返回该元素的值。此方法修改原有数组。

  ```
  var arr = ['a','b','c','d'];
  var ele = arr.shift();
  // ele结果为: a;
  // arr数组被修改: ['b''c','d'];
  
  ```

  

4. unshift()，将一个或多个元素添加到数组的开头，并返回该数组的新长度。此方法修改原有数组。

  ```
  var arr = ['a','b','c'];
  var ele = arr.unshift('d');
  // ele结果为: 4;
  // arr数组被修改: ['d','a','b','c'];
  
  ```

  

5. slice(begin,end)，返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。
begin 可选 提取起始处的索引（从0开始），从该索引开始提取原数组元素
如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取，slice(-2) 表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。
如果省略 begin，则 slice 从索引 0 开始。
如果 begin 超出原数组的索引范围，则会返回空数组。

end 可选 提取终止处的索引（从 0 开始），在该索引处结束提取原数组元素。slice 会提取原数组中索引从 begin 到 end 的所有元素（包含 begin，但不包含 end）。
slice(1,4) 会提取原数组中从第二个元素开始一直到第四个元素的所有元素 （索引为 1, 2, 3的元素）。
如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取。 slice(-2,-1) 表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。
如果 end 被省略，则 slice 会一直提取到原数组末尾。
如果 end 大于数组的长度，slice 也会一直提取到原数组末尾。

```
var arr = ['a','b','c','d'];
var res = arr.slice(0,2);
// arr数组未被修改: ['a', 'b', 'c', 'd'];
// res数组为: ['a', 'b'];

```


6. splice(start,deleteCount?,item1?) ，通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容（如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组）。此方法修改原数组。
start：
指定修改的开始位置（从0计数）。如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位开始的第几位（从-1计数，这意味着-n是倒数第n个元素并且等价于array.length-n）；如果负数的绝对值大于数组的长度，则表示开始位置为第0位。

deleteCount (可选)：
整数，表示要移除的数组元素的个数。
如果 deleteCount 大于 start 之后的元素的总数，则从 start 后面的元素都将被删除（含第 start 位）。
如果 deleteCount 被省略了，或者它的值大于等于array.length - start(也就是说，如果它大于或者等于start之后的所有元素的数量)，那么start之后数组的所有元素都会被删除。
如果 deleteCount 是 0 或者负数，则不移除元素。这种情况下，至少应添加一个新元素。

item1, item2, … （可选）：
要添加进数组的元素,从start 位置开始。如果不指定，则 splice() 将只删除数组元素。

```javascript
var arr = ['a', 'b', 'c', 'd'];
// 从索引 2 的位置开始删除 0 个元素，插入"e"
var insertOnce = arr.splice(2,0,'e');
insertOnce = []
arr = ['a', 'b', 'e', 'c', 'd']
// 从索引3的位置开始删除一个元素
var delOnce = arr.splice(3,1);
// delOnce数组为: ['c']
// arr数组被修改: ['a', 'b', 'e', 'd']

```


7. concat()，于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。

  ```
  var arr1 = ['a', 'b', 'c', 'd'];
  var arr2 = ['e','f']
  var arr3 = arr1.concat(arr2);
  // arr3数组为: ['a', 'b', 'c', 'd','e','f']
  
  ```

  

8. join()，将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符(默认使用’,'分隔，如果使用""，则所有元素之间都没有任何字符)。

  ```
  var arr = ['a','b','c','d'];
  var str = arr.join("-")
  // str结果为: "a-b-c-d"
  
  ```

  

9. sort()，对数组的元素进行排序。此方法修改原数组。

  ```
  var arr = [1,5,2,4,3]
  arr.sort()
  // arr数组被修改: [1,2,3,4,5]
  
  ```

  

10. reverse()，将数组中元素的位置颠倒，并返回该数组。数组的第一个元素会变成最后一个，数组的最后一个元素变成第一个。该方法修改原数组。

    ```
    var arr = [1,2,3,4,5];
    arr.reverse();
    // arr数组被修改: [5,4,3,2,1]
    
    ```

    

11. forEach(function(currentValue，index?,array?),thisValue?)，对数组的每个元素执行一次给定的函数。
currentValue 必选 当前元素的值

index 可选 当前元素的索引值

array 可选 当前元素属于的数组对象

thisValue 可选 执行callback函数时值被用作 this。如果省略或传入null,undefined那么callback函数的this为全局对象

```
function logArrayElements(element, index, array) {
  console.log('a[' + index + '] = ' + element);
}

// 注意索引 2 被跳过了，因为在数组的这个位置没有项
[2, 5, , 9].forEach(logArrayElements);
// logs:
// a[0] = 2
// a[1] = 5
// a[3] = 9

```



12. map(function(currentValue，index?,array?),thisValue?)，创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。

    ```javascript
    // 使用 map 重新格式化数组中的对象
        var kvArray = [{key: 1, value: 10},
                   {key: 2, value: 20},
                   {key: 3, value: 30}];
    
    var reformattedArray = kvArray.map(function(obj) {
       var rObj = {};
       rObj[obj.key] = obj.value;
       return rObj;
    });
    
    // reformattedArray 数组为： [{1: 10}, {2: 20}, {3: 30}],
    
    // kvArray 数组未被修改:
    // [{key: 1, value: 10},
    //  {key: 2, value: 20},
    //  {key: 3, value: 30}]
    
    
    ```
    
    



13. filter(function(currentValue,index,arr), thisValue)，创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。

    ```
    // 筛选出字符串数组中长度大于6的字符串
    const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];
    
    const result = words.filter(word => word.length > 6);
    
    console.log(result);
    // log: ["exuberant", "destruction", "present"]
    
    ```

    

14. every(function(currentValue,index,arr), thisValue)，测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值(若收到一个空数组，此方法在一切情况下都会返回 true)。

    ```
    // 检查是否数组中的所有数字都小于40
    const isBelowThreshold = (currentValue) => currentValue < 40;
    
    const array1 = [1, 30, 39, 29, 10, 13];
    
    console.log(array1.every(isBelowThreshold));
    // log: true
    ```

    


15. some(function(currentValue,index,arr), thisValue)，测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值(如果用一个空数组进行测试，在任何情况下它返回的都是false)。
    

    ```
    //  检测数组中是否至少有一个数字大于 18:
        var ages = [3, 10, 18, 20];
    
    function checkAdult(age) {
        return age >= 18;
    }
    
    function myFunction() {
        document.getElementById("demo").innerHTML = ages.some(checkAdult);
    }
    ```

    

16. find(function(currentValue,index,arr), thisValue)，返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。

    ```
     // 获取数组中第一个大于10的值
    const array1 = [5, 12, 8, 130, 44];
    
    const found = array1.find(element => element > 10);
    
    console.log(found);
    // expected output: 12
    ```

    

17. flat(depth?)，按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。此方法不会改变原数组。
depth 可选 指定要提取嵌套数组的结构深度，默认值为 1。

```javascript
const arr1 = [0, 1, 2, [3, 4]];

console.log(arr1.flat());
// log: [0, 1, 2, 3, 4]

const arr2 = [0, 1, 2, [[[3, 4]]]];

console.log(arr2.flat(2));
// log: [0, 1, 2, [3, 4]]
```

18. reduce

    语法：arr.**reduce**(**callback**(accumulator, currentValue, index, array), initialValue)

    ```javascript
    //求和
    let sum = [1, 2, 3, 5].reduce((acc, current) => {
     return acc + current 
    }, 0)
    
    
    //数组去重
    let arr = ['1', '2', '2', '3', '4'].reduce((acc, cur) => {
      if (!acc.includes[cur]) {
        return acc.concat(cur)
      }
      return acc
    }, [])
    // 当然还可以使用new set 
    // Array.from 从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。
    Array.from(new Set(myArray))
    
    
    //多维数组扁平化
    let arr1 = [[0, 1], [2, 3], [4, [5, 6, 7]]]
    const flattenArr = function (arr) {
      return arr.reduce((acc, cur) => {
        return acc.concat(Array.isArray(cur) ? flattenArr(cur) : cur)
      }, [])
    }
    console.log(flattenArr(arr1))
    
    
    //多维数组扁平化
    let arr = [1,[2,[3,[4,5]]],[6,[7,[8,9]]]]
    let newArr = []
    const decending = (arr) => {
      if (arr === null) {
        return arr
      }
      arr.forEach((item)=>{
        if(Array.isArray(item)){
          decending(item)
        }else{
          newArr.push(item)
        }
      })
    }
    
    decending(arr)
    console.log(newArr)
    
    ```

    

    #### 

#### 函数

- **声明函数的几种方式**

  ```javascript
  // 1,函数声明
  function 函数名(参数1，参数2，...){   //要执行的语句 } 
  // 2,函数表达式
  var func2=function(b){}//函数表达式
  var func3=function func4(c){}//命名式函数表达式
  var func5=(function(n1,n2){})();//立即执行的函数表达式
  return function(){ };//作为返回值的函数表达式
  // 3,Function构造器
  var 变量名 = new Function("参数1","参数2",...,"参数n","函数体");  
  // 4,立即执行函数
  var func5=(function(n1,n2){})();//立即执行的函数表达式 ()()
  ```

  

- **函数声明与函数表达式的区别**

  函数声明会将那个函数提升到最前面（即使你写代码的时候在代码块最后才写这个函数），成为全局函数。

  函数声明要指定函数名，而函数表达式不用，可以用作匿名函数。

- **函数调用的几种方式**

  1.直接调用 函数名加上括号 （）

  2.函数表达式 变量名（）

this指向的问题（高频）

- ##### this指向的问题

在全局的环境下this是指向window 的

普通函数调用直接调用中的this 会指向 window， 严格模式下this会指向 undefined，自执行函数 this 指向 window，定时器中的 this 指向 window

在对象里调用的this，指向调用函数的那个对象，

在构造函数以及类中的this，构造函数配合 new 使用, 而 new 关键字会将构造函数中的 this 指向实例化对象，所以构造函数中的 this 指向 当前实例化的对象

方法中的this谁调用就指向谁。

箭头函数没有自己的 this，箭头函数的this在定义的时候，会继承自外层第一个普通函数的this



#### websocket

后端地址是http的  [websocket](https://so.csdn.net/so/search?q=websocket&spm=1001.2101.3001.7020)地址 ws开头；后端地址是https的，websocket地址wss开头；

对于websocket没有[跨域](https://so.csdn.net/so/search?q=跨域&spm=1001.2101.3001.7020)的问题

**1.什么是WebSocket**

HTML5规范提供的一种浏览器与服务器进行全双工通讯的网络技术，它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。

**2.优点**

相对于http协议来说

1. 支持双向通信
2. 使用简单，只需要在浏览器中调用api就能完成协议切换
3. 支持扩展，可以在协议中实现自定义的子协议
4. 头部开销小，可以在网络中更快的传输

```javascript
import { MessageBox } from 'element-ui';
let url = "ws://192.168.0.181:8000";  //请求的后端地址
 
let websocket = null;//全局WebSocket对象
let lockReconnect = false; // 网络断开重连
let wsCreateHandler = null; // 创建连接
export function createWebSocket(fn){
  try{
    if ('WebSocket' in window) {
      websocket = new WebSocket(`${url}/webSocketServer?token=${getToken()}`);
    } else if ('MozWebSocket' in window) {
      websocket = new MozWebSocket(`${url}/webSocketServer?token=${getToken()}`);
    } else {
      websocket = new SockJS(`${url}/sockjs/webSocketServer?token=${getToken()}`);
    }
  }catch {
    reconnect();
    return;
  }
 
  websocket.onopen = function(event) {
   // websocket.send("连接成功");
    console.log("服务已连接")
  };
 
  websocket.onmessage = function(event){
    var data=JSON.parse(event.data);
    if(data.type === 'exit'){
      MessageBox.alert(data.name, '提示', {
        dangerouslyUseHTMLString: true,
        showConfirmButton: true,
        type: 'warning',
      }).then(()=>{
        store.dispatch('user/resetToken').then(() => {
          removeToken();
          // window.location.reload();
          router.replace("/login")
        });
      });
 
    }
    fn(data);
 
 
  };
  websocket.onclose = function(event) {
    console.log("服务连接关闭")
  };
  websocket.onerror = function(event) {
 
    console.log(event,"连接出错")
  };
}
/**
 *  异常处理
 * 处理可以检测到的异常，并尝试重新连接
 */
function reconnect() {
  if (lockReconnect) {
    return;
  }
  console.log("reconnect");
  lockReconnect = true;
  // 没链接上会一直连接，设置延迟，避免过多请求
  wsCreateHandler && clearTimeout(wsCreateHandler);
  wsCreateHandler = setTimeout(function() {
    console.log("-----websoket异常-------");
    createWebSocket();
    lockReconnect = false;
  }, 1000);
}
export function websocketClose() {
  console.log('执行了关闭')
  websocket.close();    //手动关闭websocket
}
```



#### Ajax

什么是ajax？ajax有什么优缺点？
ajax不是语言，ajax是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术

优点

1、最大的一点是页面无刷新，用户的体验非常好。

2、使用异步方式与服务器通信，具有更加迅速的响应能力。

缺点

1、ajax不支持浏览器back按钮。

2、安全问题 AJAX暴露了与服务器交互的细节。

3、对搜索引擎的支持比较弱。

4、破坏了程序的异常机制。

5、不容易调试

```javascript
1.创建xhr 核心对象
var xhr=new XMLHttpRequest();
​
2.调用open 准备发送
参数一：请求方式
参数二: 请求地址
参数三：true异步，false 同步
xhr.open('post','http://www.baidu.com/api/search',true)
​
3.如果是post请求，必须设置请求头。
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')
​
4.调用send 发送请求 （如果不需要参数，就写null）
xhr.send('user=tom&age=10&sex=女')
​
5.监听异步回调 onreadystatechange
判断readyState 为4 表示请求完成
判断status 状态码 为 200 表示接口请求成功
responeseText 为相应数据。字符串类型。
xhr.onreadystatechange=function(){
    if(xhr.readyState==4){ 
        if(xhr.status==200){
            console.log(xhr.responseText);
            var res=JSON.parse(xhr.responseText);
            console.log(res);
            if(res.code==1){
            modal.modal('hide');
           location.reload();
       }
    }
            
            
备注：如果是post请求，想要传json格式数据。
设置请求头
​
1.xhr.setRequestHeader('Content-Type', 'application/json')
​
open发送数据
2.xhr.open({_id:xxx,user:xxxx,age:xxxx})
```



#### Http和Https区别

1.`HTTP` 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头
2.`HTTP` 是不安全的，而 HTTPS 是安全的
3.`HTTP` 标准端口是80 ，而 HTTPS 的标准端口是443
4.`在OSI` 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层
5.`HTTP` 无法加密，而HTTPS 对传输的数据进行加密，证的网络协议，安全性高于HTTP协议。
6.`HTTP`无需证书，而HTTPS 需要CA机构wosign的颁发的SSL证书，一般免费证书少，因而需要一定费用。



#### GET和POST区别

1.GET在浏览器回退不会再次请求，POST会再次提交请求
2.GET请求会被浏览器主动缓存，POST不会，要手动设置
3.GET请求参数会被完整保留在浏览器历史记录里，POST中的参数不会
4.GET请求在URL中传送的参数是有长度限制的，而POST没有限制
5.GET参数通过URL传递，POST放在Request body中
6.GET参数暴露在地址栏不安全，POST放在报文内部更安全
7.GET一般用于查询信息，POST一般用于提交某种信息进行某些修改操作
8.GET产生一个TCP数据包；POST产生两个TCP数据包
Ge和post的选择：
1.私密性的信息请求使用post（如注册、登陆）。
2.查询信息使用get。



#### 跨域

当一个请求 url 的协议、域名、端口三者之间任意一个与当前页面 url 不同即为跨域
出于浏览器的同源策略限制。
同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。
1.JSONP原理
利用script元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 数据。
但是JSONP请求一定需要对方的服务器做支持才可以。
JSONP优点是兼容性好，可用于解决主流浏览器的跨域数据访问的问题。
缺点是仅支持get方法具有局限性。
2.CORS原理
实现CORS通信的关键是服务器，需要在服务器端做一些小小的改造。
只要服务器实现了CORS接口，就可以跨源通信。
在响应头上添加Access-Control-Allow-Origin属性，指定同源策略的地址。同源策略默认地址是网页的本身。只要浏览器检测到响应头带上了CORS，并且允许的源包括了本网站，那么就不会拦截请求响应。
3.Nginx
浏览器在访问受限时，可通过不受限的代理服务器访问目标站点。
proxy代理是前端用的最多的解决跨域的方法。
即配置一台和浏览器相同端口的服务器，浏览器访问代理服务器，代理服务器向目标服务器发送请求，由于服务器之间不存在跨域问题，代理服务器就可以拿到请求数据，而后因为浏览器和代理服务器端口号一致，不存在跨域问题，因此浏览器不会拦截从代理服务器收到的数据，顺利拿到请求数据



------



#### 浅拷贝和深拷贝

解释见：数据结构中堆和栈

常见5种深拷贝实现方法

```javascript
//	深拷贝常用方法
//	1，ES6解构赋值【注意: 这种方式只能用于单层json对象，也就是对象中的每个value都是基本类型，没有嵌套。】
let a = {key1: 1}
let b = {...a}
b.key1 = 2
console.log(a) // {key1: 1}

//	2，ES6中Object.assign【注意: 这种方式只能用于单层json对象，也就是对象中的每个value都是基本类型，没有嵌套】
var a = { key1: 1 };
var b = Object.assign({}, a);

//	3，JSON方法【这个是可以对多层json对象进行拷贝的】
const clone = JSON.parse(JSON.stringify(original));

//	4，自定义递归函数
function deepClone(o1, o2) {
    for (let k in o2) {
        if (typeof o2[k] === 'object') {
            o1[k] = {};
            deepClone(o1[k], o2[k]);
        } else {
            o1[k] = o2[k];
        }
    }
}

//	5，第三方JS库【如Lodash、Jquery】
lodash.clonedeep
$.extend([deep ], target, object1 [, objectN ])
```

------



#### 闭包

1. **什么是闭包？**

「函数」和「函数内部能访问到的变量」的总和，或者说是同一个作用域内的函数和变量总何，就是一个闭包

2. **为什么需要闭包？**

局部变量无法共享和长久保存，而全局变量可能造成变量污染，所以我们希望有一种机制既可以长久保存变量又不会造成全局污染。

3. **特点**

- [ ] 占用更多内存
- [ ] 不容易被释放

4. **何时使用？**

变量既想反复使用，又想避免全局污染，就可以使用闭包

5. **如何使用？**

- [ ] 定义外层函数，封装被保护的局部变量。

- [ ] 定义内层函数，执行对外部函数变量的操作。

- [ ] 外层函数返回内层函数的对象，并且外层函数被调用，结果保存在一个全局的变量中。

------



#### 递归

1. 什么是递归：

   如果一个函数在内部可以调用其本身，那么这个函数就是递归函数。

   简单理解:函数内部自己调用自己, 这个函数就是递归函数

2. 递归必须由以下两部分组成

   - 递归调用的过程
   - 递归终止的条件

3. 普通递归都是很消耗资源

------



#### 防抖

函数防抖（debounce）：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。持续触发click事件时，并不执行handle函数，当1000毫秒内没有触发click事件时，才会延时触发click事件。



#### 节流

函数节流（throttle）：指定时间间隔内只会执行一次任务。

规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。持续触发click事件时，并不立即执行handle函数，每隔1000毫秒才会执行一次handle函数。



二者区别
函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。

```
let _debounceTimeout = null,
	_throttleRunning = false

/**
 * 防抖
 * @param {Function} 执行函数
 * @param {Number} delay 延时ms
 */
export const debounce = (fn, delay=500) => {
	clearTimeout(_debounceTimeout);
	_debounceTimeout = setTimeout(() => {
		fn();
	}, delay);
}
/**
 * 节流
 * @param {Function} 执行函数
 * @param {Number} delay 延时ms
 */
export const throttle = (fn, delay=500) => {
	if(_throttleRunning){
		return;
	}
	_throttleRunning = true;
	fn();
	setTimeout(() => {
	    _throttleRunning = false;
	}, delay);
}
```



#### 缓存

浏览器的本地存储主要分为Cookie、WebStorage和IndexDB, 其中WebStorage又可以分为localStorage和sessionStorage。

共同点: 都是保存在浏览器端、且同源的

不同点：

- cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。

- 存储大小限制也不同，

- cookie数据不能超过4K，sessionStorage和localStorage可以达到5M

- sessionStorage：仅在当前浏览器窗口关闭之前有效；

- localStorage：始终有效，窗口或浏览器关闭也一直保存，本地存储，因此用作持久数据；

- cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭


作用域不同

- sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面；

- localstorage：在所有同源窗口中都是共享的；也就是说只要浏览器不关闭，数据仍然存在

- cookie: 也是在所有同源窗口中都是共享的.也就是说只要浏览器不关闭，数据仍然存在。



#### DOM文档对象模型

> **DOM是 document 用来表示文档中对象的标准模型，他是由节点和对象组成的结构集合**。在浏览器解析HTML标签时，会构建一个DOM树结构。

```javascript
拿到指定节点
var id = document.getElementById("id");  //返回带有指定id的元素
var name = document.getElementByTagName("li"); //返回带有指定标签的元素
var class = document.getElementByClassName("class"); //返回带有包含执行类名的所有元素节点列表。`
 创建DOM节点
var node = document.createElement("div");
var attr = document.createAttribute("class");
var text = document.createTextNode("菜呀菜");`
 插入DOM节点
node.appendChild(text) //插入新的子节点
node.insertBefore(pre,child) //在node元素内child前加入新元素`
 删除DOM节点
node.removeChild(text) //从父元素删除子元素节点
 修改DOM节点
node.setAttribute("class","name") //修改设置属性节点
node.replaceChild(pre,child)  //父节点内新子节点替换旧子节点`
 常用DOM属性
node.innerHtml  //获取/替换元素内容
node.parentNode  //元素节点的父节点
node.parentElement  //元素节点的父元素节点（一般与Node节点相同）
node.firstChild  //属性的第一个节点
node.lastChild   //属性的最后一个节点
node.nextSibling //节点元素后的兄弟元素（包括回车，空格，换行）
node.nextElementSibling //节点元素后的兄弟元素节点
node.previousSibling //获取元素的上一个兄弟节点（元素，文本，注释）
node.previousElementSibling //获取元素的上一个兄弟节点（只包含元素节点）
node.childNodes  //元素节点的子节点（空格，换行默认为文本节点）
node.children    //返回当前元素的所有元素节点
node.nodeValue   //获取节点值
node.nodeName    //获取节点名字
node.attributes  //元素节点的属性节点
node.getAttribute("name")  //元素节点的某个属性节点
node.style.width = "200px"  //设置css样式`
```



#### 状态码

```javascript
    200响应成功
    301永久重定向
    302临时重定向
    304资源缓存
    403服务器禁止访问
    404服务器资源未找到
    500 502服务器内部错误
    504 服务器繁忙
    1xx Informational（信息状态码）      接受请求正在处理
    2xx Success（成功状态码）            请求正常处理完毕
    3xx Redirection（重定向状态码）      需要附加操作已完成请求
    4xx Client Error（客户端错误状态码）  服务器无法处理请求
    5xx Server Error（服务器错误状态码）  服务器处理请求出错
```



#### 浏览器从输入url到渲染页面，发生了什么？

用户输入阶段
合成 URL：浏览区会判断用户输入是合法 URL，比如用户输入的是搜索的关键词，默认的搜索引擎会合成新的，如果符合url规则会根据url协议，在这段内容加上协议合成合法的url 

查找缓存
网络进程获取到 URL，先去本地缓存中查找是否有缓存资源，如果有则拦截请求，直接将缓存资源返回给浏览器进程；否则，进入网络请请求阶段；    
    
DNS 解析：
DNS 查找数据缓存服务中是否缓存过当前域名信息，有则直接返回；否则，会进行 DNS 解析返回域名对应的 IP 和端口号，如果没有指定端口号，http 默认 80 端口，https 默认 443。如果是 https 请求，还需要建立 TLS 连接；
    
建立 TCP 连接：
TCP 三次握手与服务器建立连接，然后进行数据的传输；（三次握手开喷）

发送 HTTP 请求：
浏览器首先会向服务器发送请求行，它包含了请求方法、请求 URI 和 HTTP 协议的版本；另外还会发送请求头，告诉服务器一些浏览器的相关信息，比如浏览器内核，请求域名；

服务器处理请求：
服务器首先返回响应行，包括协议版本和状态码，比如状态码 200 表示继续处理该请求；如果是 301，则表示重定向，服务器也会向浏览器发送响应头，包含了一些信息；

页面渲染:

查看响应头的信息，做不同的处理，比如重定向，存储cookie 看看content-type的值，根据不同的资源类型来用不同的解析方式

浏览器将获取的HTML文档解析成DOM树。
处理CSS标记，构成层叠样式表模型CSSOM(CSS Object Model)。
将DOM和CSSOM合并为渲染树(rendering tree)，代表一系列将被渲染的对象。
渲染树的每个元素包含的内容都是计算过的，它被称之为布局layout。浏览器使用一种流式处理的方法，只需要一次绘制操作就可以布局所有的元素。
将渲染树的各个节点绘制到屏幕上，这一步被称为绘制painting。

断开 TCP 连接：

数据传输完成，正常情况下 TCP 将四次挥手断开连接。但是如果浏览器或者服务器在HTTP头部加上 Connection: keep-alive，TCP 就会一直保持连接





### ES6基础知识

#### ES6 新增特性

1. 新增了块级作用域(let,const)

2. 提供了定义类的语法糖(class)

3. 新增了一种基本数据类型(Symbol)

4. 新增了变量的解构赋值

5. 函数参数允许设置默认值，引入了 rest 参数，新增了箭头函数

6. 数组新增了一些 API，如 isArray / from / of 方法;数组实例新增了entries()，keys() 和 values() 等方法

7. 对象和数组新增了扩展运算符

8. ES6 新增了模块化(import/export)

9. ES6 新增了 Set 和 Map 数据结构

10. ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例

11. ES6 新增了生成器(Generator)和遍历器(Iterator)

    

#### require与import的区别和使用(CommonJS规范和es6规范)

1、import是ES6中的语法标准也是用来加载模块文件的，import函数可以读取并执行一个JavaScript文件，然后返回该模块的export命令指定输出的代码。export与export default均可用于导出常量、函数、文件、模块，export可以有多个，export default只能有一个。

2、require 定义模块：module变量代表当前模块，它的exports属性是对外的接口。通过exports可以将模块从模块中导出，其他文件加载该模块实际上就是读取module.exports变量，他们可以是变量、函数、对象等。在node中如果用exports进行导出的话系统会系统帮您转成module.exports的，只是导出需要定义导出名。

require与import的区别

1，require是CommonJS规范的模块化语法，import是ECMAScript 6规范的模块化语法；

2，require是运行时加载，import是编译时加载；

3，require可以写在代码的任意位置，import只能写在文件的最顶端且不可在条件语句或函数作用域中使用；

4，require通过module.exports导出的值就不能再变化，import通过export导出的值可以改变；

5；require通过module.exports导出的是exports对象，import通过export导出是指定输出的代码；

6，require运行时才引入模块的属性所以性能相对较低，import编译时引入模块的属性所所以性能稍高



#### 箭头函数

1、 箭头函数是匿名函数不能作为构造函数，不能使用new

2、 箭头函数不绑定arguments,取而代之用rest参数…解决，

3、 this指向不同,箭头函数的this在定义的时候继承自外层第一个普通函数的this

4、 箭头函数通过call()或apply()调用一个函数,只传入了一个参数,对this并没有影响.

5、 箭头函数没有prototype(原型)，所以箭头函数本身没有this

6、 箭头函数不能当做Generator函数,不能使用yield关键字、

7、 写法不同，箭头函数把function省略掉了 （）=> 也可以吧return 省略调 写法更简洁

8、箭头函数不能通过call（）、apply（）、bind（）方法直接修改它的this指向。

#### Promise

1. Promise是一个构造函数



<div align=""> <a href="https://gitee.com/zhixi0912/study"> <img alt="Logo" width="564" height:"132" src="https://cdn.staticaly.com/gh/zhixi0912/blog.github.io@master/images/summarize/image-20221222082001507.756hl0y5s180.webp"> </a> <br> <br>

2. Promise的状态

​	实例对象中的一个属性 【PromiseState】

- pending	未决定
- Resolved / fullfilled  成功
- Rejected  失败

3.	Promise对象的值 

实例对象中的另一个属性 【PromiseResult】

保存着异步任务【成功/失败】的结果

4. Promise的工作流程

![image-20221222081917748](https://cdn.staticaly.com/gh/zhixi0912/blog.github.io@master/images/summarize/image-20221222081917748.74okg4hosaw0.webp)





#### async、await的原理

Async 和 await 是一种同步的写法，但还是异步的操作，两个必须配合一起使用

函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象。

await 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西，如果是promise则会等待promaise 返回结果，接普通函数直接进行链式调用.

await 能够获取promise执行的结果 await必须和async一起使用才行，async配合await使用是一个阻塞的异步方法

如果await后面不是Promise对象, 就直接返回对应的值，只能在async函数中出现, 普通函数直接使用会报错

await语句后的Promise对象变成reject状态时，那么整个async函数会中断，后面的程序不会继续执行



#### js 的几种模块规范

js 中现在比较成熟的有四种模块加载方案：

1. 第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。

2. 第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。

3. 第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。

4. 第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。

------





### TypeScript

​	type: `type`关键字是声明类型别名的关键字。它的语法如下：

```javascript
type AliasName = Type;
// type：声明类型别名的关键字
// AliasName：类型别名的名称
// Type：类型别名关联的具体类型
```

​	interface:通过关键字 `interface`可以定义一个[接口类型](https://so.csdn.net/so/search?q=接口类型&spm=1001.2101.3001.7020)。它能合并众多类型声明至一个类型声明。

接口声明只存在于编译阶段，在编译后生成的 JS 代码中不包含任何接口代码。

语法如下：

```javascript
interface InterfaceName {
  TypeMember;
  TypeMember;
  ...
}
// interface：定义接口的关键字
// InterfaceName：接口名，首字母需要大写
// TypeMember：接口的类型成员
```

相同点

- 都可以用来定义 **对象** 或者 **函数** 的结构，而严谨的来说，type 是引用，而 `interface`是定义

不同点

- type 在声明类型别名之后**实际上是一个赋值操作，它需要将别名与类型关联起来**。也就是说类型别名不会创建出一种新的类型，它只是给已有类型命名并直接进行引用。`interface`是**定义了一个接口类型。**
- type 能够**表示非对象类型，** 而 `interface` 则**只能表示对象类型**。
- `interface`可以**继承其他的接口、类等对象类型，** type 不支持继承。
- `interface`接口名总是会直接显示在编译器的诊断信息和代码编辑器的智能提示中，而 **type 的名字只在特定情况**下才会显示出来——只有当类型别名表示**数组类型、元组类型以及类或者接口的泛型实例类型**时才展示。
- `interface`具有声明合并的行为，而 `type`不会，这也意味着我们可以通过声明合并的方式给 `interface`定义的类型进行属性扩展。
- `type`可以通过 `typeof`来获取实例的类型从而进行赋值操作

------



## 前端进阶

### 软件架构设计模式

1. MVC（模型—视图—控制器）

   它通过关注点分离鼓励改进应用程序组织。它强调将业务数据(Model)与用户界面(View)隔离

   Controller可以直接访问Model，也可以直接控制View,但是Model和View不能相互通信，相当于COntroller就是介于这两者之间的协调者。

   

2. MVVM (M模型—V控制器—VM视图模型)

   ViewModel(视图模型):就是View和Model层的粘合剂，封装业务逻辑处理，封装网络处理，封装数据缓存。就是把原来ViewController层的业务逻辑和页面逻辑等剥离出来放到ViewModel层

   vue2中的双向绑定数据就是典型的MVVM模式

   

3. 微前端

   

   ------

   



### vue2.js

#### vue2实现原理

Vue2 是采用数据劫持结合发布者-订阅者模式的方式来实现数据的响应式，通过 Object.defineProperty() 方法进行的数据劫持，通过递归的方式对所有属性都添加 setter、getter 方法进行监听，在数据变动时发布消息给订阅者，订阅者收到消息后进行相应的处理。

当访问或设置对象的属性的时候，都会触发相对应的函数，然后在这个函数里返回或设置属性的值，我们可以在触发函数的时候做点我们自己想做的事情，这也就是“劫持”操作。

> vue发布与订阅

1. observer，创建数据监听，并为每个属性建立一个发布类。

2. Dep是发布订阅者模型中的发布者：get数据的时候，收集订阅者，触发Watcher的依赖收集；set数据时发布更新，通知Watcher 。一个Dep实例对应一个对象属性或一个被观察的对象，用来收集订阅者和在数据改变时，发布更新。

3. Watcher是发布订阅者模型中的订阅者：订阅的数据改变时执行相应的回调函数（更新视图或表达式的值）。一个Watcher可以更新视图，如html模板中用到的{{test}}，也可以执行一个$watch监督的表达式的回调函数（Vue实例中的watch项底层是调用的$watch实现的）,还可以更新一个计算属性（即Vue实例中的computed项）

新增或删除对象属性，界面不会更新。【`this.$set`、 `Vue.set` 和 `splice`（仅数组适用）】

直接通过下标修改数组，界面不会更新

```javascript
//	如果是object，则通过Object.defineProperty(obj,key,descriptor)拦截对象属性访问
function defineReactive(obj, key, val) {
  Object.defineProperty(obj, key, {
    get() {
      return val
    },
    set(v) {
      val = v
      notify()
    }
  })
}
//	如果是数组，则覆盖数组的7个变更方法实现变更通知
const arrayProto = Array.prototype
const arrayMethods = Object.create(arrayProto)

;['push','pop','shift','unshift','splice','sort','reverse']
  .forEach(function (method) {
  const original = arrayProto[method]
  def(arrayMethods, method, function mutator (...args) {
    const result = original.apply(this, args)
    notify()
    return result
  })
})
/* 问题：
1,初始化时需要遍历对象所有key，如果对象层级较深，性能不好
2,通知更新过程需要维护大量dep实例和watcher实例，额外占用内存较多
3,动态新增、删除对象属性无法拦截，只能用特定set/delete api代替
4,不支持新的Map、Set等数据结构
*/
```

优点：

- 降低耦合：视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的"View"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。
- 可重用性：可以把一些视图逻辑放在ViewModel层中，让很多View重用这些视图逻辑。
- 独立开发：开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。
- 可测试：界面素来是比较难于测试的，测试可以针对ViewModel来写。

缺点：

- 深度监听，需要递归到底，一次性计算量大，资源消耗大
- 无法监听新增、删除属性（需要vue.set 和 vue.delete）
- 无法原生监听数组，需要特殊处理

------

#### deff算法

1. diff算法是干什么的

   diff算法是一种通过同层的树节点进行比较的高效算法

   它有2个特点：1，比较只会在同层级中，不会跨层级。2，在diff比较的过程中，循环从两边向中间比较

2. vue中的diff算法

   Vue中的diff算法称为patching算法，它由Snabbdom修改而来，虚拟DOM要想转化为真实DOM就需要通过patch方法转换，是对新旧两条虚拟DOM进行逐层比较并更新真实DOM。

   当页面上的数据发生变化时，Vue 不会立即渲染。而是经过 diff 算法，判断出哪些是不需要变化的，哪些是需要变化更新的，只需要更新那些需要更新的 DOM 就可以了，这样就减少了很多不必要的 DOM 操作，大大提升了性能。

   最初Vue1.x视图中每个依赖均有更新函数对应，可以做到精准更新，因此并不需要虚拟DOM和patching算法支持，但是这样粒度过细导致Vue1.x无法承载较大应用；Vue 2.x中为了降低Watcher粒度，每个组件只有一个Watcher与之对应，此时就需要引入patching算法才能精确找到发生变化的地方并高效更新。

3. 它何时执行及具体执行方式

   vue中diff执行的时刻是组件内响应式数据变更触发实例执行其更新函数时，更新函数会再次执行render函数获得最新的虚拟DOM，然后执行patch函数，并传入新旧两次虚拟DOM，通过比对两者找到变化的地方，最后将其转化为对应的DOM操作。

   patch过程是一个递归过程，遵循深度优先、同层比较的策略；以vue3的patch为例：

   - 首先判断两个节点是否为相同同类节点，不同则删除重新创建
   - 如果双方都是文本则更新文本内容
   - 如果双方都是元素节点则递归更新子元素，同时更新元素属性
   - 更新子节点时又分了几种情况：
     - 新的子节点是文本，老的子节点是数组则清空，并设置文本；
     - 新的子节点是文本，老的子节点是文本则直接更新文本；
     - 新的子节点是数组，老的子节点是文本则清空文本，并创建新子节点数组中的子元素；
     - 新的子节点是数组，老的子节点也是数组，那么比较两组子节点，更新细节

    

4. 关键词

   sameVnode，patchVnode，updateChildren



#### vue生命周期

1. vue2->vue3生命周期对应关系

   ```javascript
   beforeCreate -> setup	//创建前
   created -> setup	//创建后
   beforeMount -> onBeforeMount	//加载前
   mounted -> onMounted	//加载后
   beforeUpdate -> onBeforeUpdate	//更新前
   updated -> onUpdated	//更新后
   beforeDestroy -> onBeforeUnmount	//销毁前
   destroyed -> onUnmounted	//销毁后
   ```

   

2. 父子组件挂载顺序

   ```javascript
   父beforeCreate -> 父created -> 父beforeMount -> 
   子beforeCreate -> 子created -> 子beforeMount -> 子mounted -> 
   父mounted
   ```

   

3. 父子组件更新顺序

   ```javascript
   父beforeUpdate -> 子beforeUpdate -> 子updated -> 父updated
   ```

   

4. 父子组件销毁顺序

   ```javascript
   父beforeDestroy -> 子beforeDestroy -> 子destroyed -> 父destroyed
   ```





#### 请求数据

一般在哪个生命周期请求异步数据?

可以啊钩子函数中的 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。

在created中最好

能更快获取到服务端数据，减少页面加载时间，用户体验更好；

SSR不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性。

mounted 在请求完数据之后需要对 dom 进行操作的时候可以用到






#### computed计算属性

**什么是计算属性**

模板内的表达式非常便利，但是设计它们的初衷是用于**简单运算的**。在模板中放入太多的逻辑会让模板过重且难以维护。

**原理**

底层借助了Object.[defineproperty](https://so.csdn.net/so/search?q=defineproperty&spm=1001.2101.3001.7020)方法提供的getter和setter

优势

与methods实现相比，内部有缓存机制（复用），效率更高，调用方便

与watch相比，无法实现异步请求



#### 路由

路由模式 

路由有两种模式 hash和history模式 默认是hash

1、hash ——即地址栏 URL 中的#符号，它的特点在 于：hash 虽然出现 URL 中，但不会被包含在 HTTP 请求中，对后端完全没有影 响，因此改变 hash 不会重新加载页面。

实现原理：

> ocation.hash 的值实际就是 URL 中#后面的东西 它的特点在于：hash 虽然出现 URL 中，但不会被包含在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。
>
> 可以为 hash 的改变添加监听事件
> window.addEventListener("hashchange", funcRef, false);
>
> 每一次改变 hash（window.location.hash），都会在浏览器的访问历史中增加一个记录利用 hash 的以上特点，就可以来实现前端路由“更新视图但不重新请求页面”的功能了
> 特点：兼容性好但是不美观

2、history ——利用了 HTML5 History api 在浏览器中没有# 有浏览器兼容问题

history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 地址后加上/items/id。后端如果缺少对 /items/id 的路由处理，将返回 404 错误。

实现原理：

> 利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。
> 这两个方法应用于浏览器的历史记录站，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。这两个方法有个共同的特点：当调用他们修改浏览器历史记录栈后，虽然当前 URL 改变了，但浏览器不会刷新页面，这就为单页应用前端路由“更新视图但不重新请求页面”提供了基础。

vue-router的实现原理(核心)：更新视图但不重新请求页面。

1. hash ——即地址栏 URL 中的#符号，它的特点在 于：hash 虽然出现 URL 中，但不会被包含在 HTTP 请求中，对后端完全没有影 响，因此改变 hash 不会重新加载页面。

2. history ——利用了 HTML5 History api 在浏览器中没有# 有浏览器兼容问题

3. history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，否则返回 404 错误。

4. vue路由的跳转方式有几种
   (1)、<router-link to="需要跳转到页面的路径"> 

   (2)、this.$router.push()跳转到指定的url，并在history中添加记录，点击回退返回到上一个页面

5. this.$router.replace()跳转到指定的url，但是history中不会添加记录，点击回退到上上个页面

6. this.$touter.go(n)向前或者后跳转n个页面，n可以是正数也可以是负数



router.push、router.replace、router.go、router.back的区别？

- router.push：跳转，并向history栈中加一个记录，可以后退到上一个页面
- router.replace：跳转，不会向history栈中加一个记录，不可以后退到上一个页面

- router.go：传正数向前跳转，传负数向后跳转

- router.back 返回到上一级页面



vue 路由传参数如何实现
主要通过 query 和 params 来实现

- (1) query可以使用name和path而params只能使用name

- (2) 使用params传参刷新后不会保存，而query传参刷新后可以保存

- (3) Params在地址栏中不会显示，query会显示

- (4) Params可以和动态路由一起使用，query不可以

- （5）to=”/goods?id=1001”this.然后在接收的页面通过 $route.query.id 来接收



vue-router 路由钩子函数是什么 执行顺序是什么执行顺序

```javascript
一、打开页面的任意一个页面，没有发生导航切换。
全局前置守卫beforeEach (路由器实例内的前置守卫)
路由独享守卫beforeEnter(激活的路由)
组件内守卫beforeRouteEnter(渲染的组件)
全局解析守卫beforeResolve(路由器实例内的解析守卫)
全局后置钩子afterEach(路由器实例内的后置钩子)
​
二、如果是有导航切换的(从一个组件切换到另外一个组件)
组件内守卫beforeRouteLeave(即将离开的组件)
全局前置守卫beforeEach (路由器实例内的前置守卫)
组件内守卫beforeRouteEnter(渲染的组件)
全局解析守卫beforeResolve(路由器实例内的解析守卫)
全局后置钩子afterEach(路由器实例内的后置钩子)
​
​
完整的导航解析流程
导航被触发。
在失活的组件里调用 beforeRouteLeave 守卫。
调用全局的 beforeEach 守卫。
在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。
在路由配置里调用 beforeEnter。
解析异步路由组件。
在被激活的组件里调用 beforeRouteEnter。
调用全局的 beforeResolve 守卫 (2.5+)。
导航被确认。
调用全局的 afterEach 钩子。
触发 DOM 更新。
调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。
```



#### vuex

vuex有哪几种属性，怎么使用？哪种功能场景使用它

vuex是一个专门为vue.js开发的状态管理模式，每一个vuex应用核心就是store(仓库)。store基本上就是一个容器，它包含着你的应用中大部分的state(状态)
vuex的状态存储是响应式的，当 vue组件中store中读取状态时候，若store中的状态发生变化，那么相应的组件也会相应地得到高效更新。
改变store中的状态的唯一途径就是显示 commit(提交)mutation，这样使得我们可以方便地跟踪每一个状态的变化。

- State: 定义了应用状态的数据结构，可以在这里设置默认的初始状态
- Getter: 允许组件从Stroe中获取数据， mapGetters辅助函数仅仅是将store中的getter映射到计算属性。
- Mutation: 唯一更改store中状态的方法，且必须是同步函数。
- Action: 用于提交muatation, 而不是直接变更状态，可以包含任意异步操作。
- Module: modules，可以让每一个模块拥有自己的state、mutation、action、getters，使得结构非常清晰，方便管理；如果所有的状态或者方法都写在一个store里面，将会变得非常臃肿，难以维护。

vuex中state存储的数据如果页面刷新此时数据还会有吗?

刷新之后销毁了

使用vuex的数据持久化的实现方式

1. 利用浏览器的本地存储localStorage和sessionStorage

   vuex的state在localStorage或sessionStorage取值

   在mutations里面，定义的方法对vuex的状态操作的同时，对存储也做对应的操作

2. 利用vue-presistedstate插件

   原理和方法1一样，也是结合了浏览器的本地存储localStorage和sessionStorage，只不过是统一的配置，不需要每次都手写存储方法。

   安装方式；npm install vuex-persistedstate --save

   引入：在store下的index.js中引入，然后使用插件plugins



#### 组件通信

1. props、emit【单向数据流】

2. $parent、$children【难以定位】

2. Ref、$refs【非响应式】

2. $attrs、$listeners【多级嵌套】

2. $emit、$on【事件总线】

3. provide和inject【依赖、注入】

   ```javascript
   // vue2实现
   
   // 根组件
   ...
   data() {
    return {
     msg: ‘I am origin component data’
    }
   },
   provide: function() {
    return {
     getData() {
      console.log(‘hi，I come from origin component’)
     }
    },
    msg: this.msg
   },
   ...
   
   //子组件
   ...
   inject: [‘getData’, ‘msg’],
   created() {
    this.init()
   },
   methods: {
    init() {
     console.log(this.msg),
     this.getData()
    }
   }
   ...
   
   ```



```javascript
// vue3实现

// 根组件
import { ref, provide, readonly } from 'vue'
const name = ref('admin')	// 提供动态数据
provide('name', readonly(name)) // readonly函数提供数据只读功能，保持单向数据流，防止子组件改变根组件中的数据

//子组件
import { ref, inject } from 'vue'
const name = inject('name', 'user') // 第二个参数是如果取值时没有取到而给的一个默认值，防止程序报错

...
<input v-model="name" type="text" />
```

注意：如果中间组件有同名provide，子组件inject取值会遵循就近原则，也就是中间组件的同名provide值会覆盖根组件的值



#### keep-alive(路由缓存)

在平常开发中，有部分组件没有必要多次初始化，这时，我们需要将组件进行持久化，**使组件的状态维持不变**，在下一次展示时，也不会进行重新初始化组件。

也就是说，`kee-alive` 是 `Vue` 内置的一个组件，可以**使被包含的组件保留状态，或避免重新渲染** 。也就是所谓的**组件缓存**

##### 基本用法

```xml
//被keep-alive包含的组件会被缓存
<keep-alive>
    <component />
</keep-alive>
```

被`keep-alive`包含的组件不会被再次初始化，也就意味着**不会重走生命周期函数**
 但是有时候是希望我们缓存的组件可以能够再次进行渲染，这时`Vue`为我们解决了这个问题
 被包含在 `keep-alive` 中创建的组件，会多出两个生命周期的钩子: `activated` 与 `deactivated`：

- `activated` 当 `keep-alive` 包含的组件再次渲染的时候触发
- `deactivated` 当 `keep-alive` 包含的组件销毁的时候触发

**`keep-alive`是一个抽象的组件，缓存的组件不会被`mounted`,为此提供`activated`和`deactivated`钩子函数**

**在2.1.0 版本后`keep-alive`新加入了两个属性: `include`(包含的组件缓存生效) 与 `exclude`(排除的组件不缓存，优先级大于`include`) 。**

在VUE3中，当组件在 `<keep-alive>` 内被切换时，它的 `mounted` 和 `unmounted` 生命周期钩子不会被调用，取而代之的是`activated`和`deactivated`.

###### 参数理解

`keep-alive`可以接收3个属性做为参数进行匹配对应的组件进行缓存:

- `include`包含的组件(可以为字符串，数组，以及正则表达式,只有匹配的组件会被缓存)
- `exclude`排除的组件(以为字符串，数组，以及正则表达式,任何匹配的组件都不会被缓存)
- `max`缓存组件的最大值(类型为字符或者数字,可以控制缓存组件的个数)

**注：当使用正则表达式或者数组时，一定要使用`v-bind`**

**代码示例：**

```javascript
// 只缓存组件name为a或者b的组件
<keep-alive include="a,b"> 
  <component />
</keep-alive>

// 组件name为c的组件不缓存(可以保留它的状态或避免重新渲染)
<keep-alive exclude="c"> 
  <component />
</keep-alive>

// 如果同时使用include,exclude,那么exclude优先于include， 下面的例子只缓存a组件
<keep-alive include="a,b" exclude="b"> 
  <component />
</keep-alive>

// 如果缓存的组件超过了max设定的值5，那么将删除第一个缓存的组件
<keep-alive exclude="c" max="5"> 
  <component />
</keep-alive>

```

###### 配合`router`使用

`router-view`也是一个组件，如果直接被包在`keepalive`里面，那么所有路径匹配到的视图组件都会被缓存，如下：

```xml
<keep-alive>
    <router-view>
        <!-- 所有路径匹配到的视图组件都会被缓存！ -->
    </router-view>
</keep-alive>

```

**如果只想要`router-view`里面的某个组件被缓存，怎么办？**

- 使用 `include/exclude`
- 使用 `meta` 属性

1.使用 `include` (`exclude`例子类似)

```xml
//只有路径匹配到的 name 为 a 组件会被缓存
<keep-alive include="a">
    <router-view></router-view>
</keep-alive>

```

2.使用 `meta` 属性

```yaml
// routes 配置
export default [
  {
    path: '/',
    name: 'home',
    component: Home,
    meta: {
      keepAlive: true // 需要被缓存
    }
  }, {
    path: '/profile',
    name: 'profile',
    component: Profile,
    meta: {
      keepAlive: false // 不需要被缓存
    }
  }
]

<keep-alive>
    <router-view v-if="$route.meta.keepAlive">
        <!-- 这里是会被缓存的视图组件，比如 Home！ -->
    </router-view>
</keep-alive>

<router-view v-if="!$route.meta.keepAlive">
    <!-- 这里是不会被缓存的视图组件，比如 Profile！ -->
</router-view>

```

###### 防坑指南

1.`keep-alive` 先匹配被包含组件的 `name` 字段，如果 `name` 不可用，则匹配当前组件 `components` 配置中的注册名称。
 2.`keep-alive` 不会在函数式组件中正常工作，因为它们没有缓存实例。
 3.当匹配条件同时在 `include` 与 `exclude` 存在时，以 `exclude` 优先级最高(当前vue 2.4.2 version)。比如：包含于排除同时匹配到了组件A，那组件A不会被缓存。
 4.包含在 `keep-alive` 中，但符合 `exclude` ，不会调用`activated`和 `deactivated`。



##### **vue3中的用法**

`<keep-alive>` 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。`<keep-alive>` 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。当组件在 `<keep-alive>` 内被切换时，它的 `mounted` 和 `unmounted` 生命周期钩子不会被调用，取而代之的是`activated`和`deactivated`.

###### 使用

- ##### 在路由组件配置文件当中配置组件是否需要被缓存，配置`meta`属性

```js
{ 
  path: '/dynamic', 
  name: 'Dynamic', 
  component: () => import('@/views/Dynamic.vue'), 
  meta: { 
    keepAlive: true, 
    showFooter: true, 
   } 
},

```

- ##### 在根组件`App.vue`中使用`keep-alive`标签包含需要缓存的组件

```js
<!-- 这是vue3的写法，与vue2的写法有所区别，如果这里使用vue2.x写法，会有警告 -->
<router-view v-slot="{ Component }">
  <keep-alive>
    <component :is="Component" :key="$route.name" v-if="$route.meta.keepAlive" />
  </keep-alive>
  <component :is="Component" :key="$route.name" v-if="!$route.meta.keepAlive" />
</router-view>

```

- ##### 缓存页面使用

```js
onActivated(() => { // 被包裹组件被激活的状态下触发
      // 逻辑代码
 }
onDeactivated(() => { // 在被包裹组件停止使用时触发
    // 逻辑代码
})

```

###### 注意

- `页面第一次进入的时候，钩子触发的顺序是created->mounted->activated，所以别在mounted和activated方法中写相同的逻辑代码`
- `多页面缓存需要配置key属性，来表示组件的唯一性和对应关系，如：:key="$route.path"`
- `不要动态修改meta.keepAlive的值控制是否缓存，因为第一次是创建组件，没有缓存，需要缓存后，下一次进入才不会触发逻辑代码，如果最开始进入的时候meta.keepAlive值为false的话，渲染的是没有使用keep-alive的组件，则会触发相应代码`





#### vue常见修饰符

什么是修饰符？**修饰符 (Modifiers)：** 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。

1. 事件修饰符【用法：@click.stop="submit"】

   - .stop - 阻止单击事件继续传播, 也就是阻止冒泡

   - .prevent - 提交事件不再重新加载页面, 可以用来阻止表单提交的默认行为

     注意点: .stop和.prevent可以串联在一起使用,都会生效

   - .capture - 内部元素触发的事件先在此处理，然后才交由内部元素进行处理

   - .self - 只当在 event.target 是当前元素自身时触发处理函数,即事件不是从内部元素触发的
     注意点: 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 

   - v-on:click.self.prevent 只会阻止对元素自身的点击。

   .once - 点击事件将只会触发一次, 不只能对原生DOM时间生效,还可以用在自定义组件上
   .passive - 立即触发默认行为,能够提升移动端性能,和.prevent一起使用时.prevent会被忽略并警告
   .native - 使用时将被当做原生的HTML标签看待,绑定事件可以生效

2. 按键修饰符【用法：@keyup.keyCode="shout()"】

   - .keyup - 键盘抬起
   - .keydow - 键盘按下
   - 按键码 - 在按键修饰符后面添加,用于监听键盘按下哪个键【如：.enter、.up、.down】

3. 系统修饰键【用法：@click.ctrl="submit"】

   - **`.ctrl`**	按住ctrl后点击才有效果
   - **`.alt`**
   - **`.shift`**
   - **`.meta`**

4. 鼠标按键修饰符【用法：@click.left="submit"】

   - .left - 只有鼠标左键点击触发`
   - `.right - 只有鼠标右键点击触发`
   - .middle - 只有鼠标中键点击触发`

5. 表单修饰符【用法：v-model.number】

   - .lazy - 在表单输入时不会马上显示在页面,而是等输入完成失去焦点时才会显示在页面
   - .trim - 过滤表单输入时前后的空格
   - .number - 限制输入数字或将输入的数据转为数字

------





#### mixins混入使用

1. 什么是Mixins？

   mixins（混入），官方的描述是一种分发 Vue 组件中可复用功能的非常灵活的方式，mixins是一个js对象，它可以包含我们组件中script项中的任意功能选项，如data、components、methods 、created、computed等等。我们只要将共用的功能以对象的方式传入 mixins选项中，当组件使用 mixins对象时所有mixins对象的选项都将被混入该组件本身的选项中来，这样就可以提高代码的重用性，使你的代码保持干净和易于维护。

2. 什么时候使用Mixins？

   当我们存在多个组件中的数据或者功能很相近时，我们就可以利用mixins将公共部分提取出来，通过 mixins封装的函数，组件调用他们是不会改变函数作用域外部的。

3. 如何创建Mixins？

   在src目录下创建一个mixins文件夹，文件夹下新建一个myMixins.js文件。前面我们说了mixins是一个js对象，所以应该以对象的形式来定义myMixins，在对象中我们可以和vue组件一样来定义我们的data、components、methods 、created、computed等属性，并通过export导出该对象

   <img src="https://cdn.staticaly.com/gh/zhixi0912/blog.github.io@master/images/summarize/20200805173501551.5bd5d911m2g0.png" alt="img" style="zoom:67%;" />

4. 如何使用Mixins？

   在需要调用的组件中引入myMixins.js文件，然后在export default 中引入你需要的对象即可

   <img src="https://cdn.staticaly.com/gh/zhixi0912/blog.github.io@master/images/summarize/20200805173523981.3irx6goxxey0.png" alt="img" style="zoom:80%;" />

5. 与vuex的区别

   **vuex：**用来做状态管理的，里面定义的变量在每个组件中均可以使用和修改，在任一组件中修改此变量的值之后，其他组件中此变量的值也会随之修改。

   **Mixins：**可以定义共用的变量，在每个组件中使用，引入组件中之后，各个变量是相互独立的，值的修改在组件中不会相互影响。

6. 与公共组件的区别

   **组件**：在父组件中引入组件，相当于在父组件中给出一片独立的空间供子组件使用，然后根据props来传值，但本质上两者是相对独立的。

   **Mixins：**则是在引入组件之后与组件中的对象和方法进行合并，相当于扩展了父组件的对象与方法，可以理解为形成了一个新的组件。

------



#### nextTick

1. nextTick是Vue提供的一个全局API，由于vue的异步更新策略导致我们对数据的修改不会立刻体现在dom变化上，此时如果想要立即获取更新后的dom状态，就需要使用这个方法
2. Vue 在更新 DOM 时是**异步**执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。nextTick方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用。
3. 所以当我们想在修改数据后立即看到dom执行结果就需要用到nextTick方法。比如，我在干什么的时候就会使用nextTick，传一个回调函数进去，在里面执行dom操作即可。
4. 它会在callbacks里面加入我们传入的函数，然后用timerFunc异步方式调用它们，首选的异步方式会是Promise。这让我明白了为什么可以在nextTick中看到dom操作结果。

```javascript
// vue2
<a-boo v-if="otherParam.showA"></a-boo>
this.abc = false
this.$nextTick(() => {
   //你要执行的方法
     this.abc = true
})


// vue3
import { nextTick } from 'vue'
setup() {
    const message = ref('Hello!')
    // 异步中使用
    const changeMessage = async newMessage => {	
      message.value = newMessage
      await nextTick()
    }
    // 普通用法
    let otherParam = reactive({
        showA:false
    })
    nextTick(()=>{
        otherParam.showA = true
    })
  }

```



------



#### 扩展Vue组件

常见的组件扩展方法有：mixins，slots，extends等

混入的数据和方法不能明确判断来源且可能和当前组件内变量产生命名冲突，vue3中引入的composition api，可以很好解决这些问题

------



#### 提升vue性能

- 路由懒加载减少应用尺寸，图片懒加载，组件懒加载
- 利用SSR减少首屏加载时间【服务端渲染】
- 利用v-once渲染那些不需要更新的内容，按条件跳过更新时使用`v-momo`
- 一些长列表可以利用虚拟滚动技术避免内存过度占用
- 对于深层嵌套对象的大数组可以使用shallowRef或shallowReactive降低开销
- 避免不必要的组件抽象
- `keep-alive`缓存页面
- 事件的销毁：Vue 组件销毁时，会自动解绑它的全部指令及事件监听器，但是仅限于组件本身的事件
- 第三方插件按需引入。



#### 页面优化

```javascript
- 减少 HTTP请求数
- 从设计实现层面简化页面
- 合理设置 HTTP缓存
- 资源合并与压缩
- 合并 CSS图片，减少请求数的又一个好办法。
- 将外部脚本置底（将脚本内容在页面信息内容加载后再加载）
- 多图片网页使用图片懒加载。
- 在js中尽量减少闭包的使用
- 尽量合并css和js文件
- 尽量使用字体图标或者SVG图标，来代替传统的PNG等格式的图片
- 减少对DOM的操作
- 在JS中避免“嵌套循环”和 “死循环”
- 尽可能使用事件委托（事件代理）来处理事件绑定的操作
- 浏览器缓存
- 防抖、节流
- 资源懒加载、预加载
- 开启Nginx gzip压缩
三个方面来说明前端性能优化
一： webapck优化与开启gzip压缩
    1.babel-loader用 include 或 exclude 来帮我们避免不必要的转译，不转译node_moudules中的js文件
    其次在缓存当前转译的js文件，设置loader: 'babel-loader?cacheDirectory=true'
    2.文件采用按需加载等等
    3.具体的做法非常简单，只需要你在你的 request headers 中加上这么一句：
    accept-encoding:gzip
    4.图片优化，采用svg图片或者字体图标
    5.浏览器缓存机制，它又分为强缓存和协商缓存
二：本地存储——从 Cookie 到 Web Storage、IndexedDB
    说明一下SessionStorage和localStorage还有cookie的区别和优缺点
三：代码优化
    1.事件代理
    2.事件的节流和防抖
    3.页面的回流和重绘
    4.EventLoop事件循环机制
    5.代码优化等等
```



------





### vue3.js

#### vue3实现原理

​	Vue3 是实现原理是用 ES6 中的 Proxy 方法来实现的

```javascript
/* target: 目标对象，待要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。 */
/* handler: 一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 proxy 的行为。 */ 
const proxy = new Proxy(target, handler);
```

​	Proxy 对象用于创建一个对象的代理，通过handler对象的拦截方法从而实现目标对象target的基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。可以理解为，在目标对象之前有一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。

​	Proxy 并不能监听到对象内部深层次的属性变化，因此它的处理方式是在 get 中去递归响应性，这样做的好处是真正访问到的内部属性才会变成响应性，简单的可以说是按需实现响应性，减少性能消耗

```javascript
function defineReactive(obj) {
  return new Proxy(obj, {
    get(target, key) {
      track(target, key)
      return Reflect.get(target, key)
    },
    set(target, key, val) {
      Reflect.set(target, key, val)
      trigger(target, key)
    },
    deleteProperty(target, key) {
      Reflect.deleteProperty(target, key)
      trigger(target, key)
    }
  })
}
//	可以同时支持object和array，动态属性增、删都可以拦截，新增数据结构均支持，对象嵌套属性运行时递归，用到才代理，也不需要维护特别多的依赖关系
```

​	

> target的拦截操作

​	get 拦截对象属性的读取

​	set 拦截对象属性的设置

​	has 拦截 key in proxy 的操作

​	deleteProperty

​	...

Proxy 支持 13 种拦截操作，除了上面的的几种常见的操作，还支持其它多种行为的拦截

| 实现原理 | defineProperty           | Proxy                   | value setter      |
| -------- | ------------------------ | ----------------------- | ----------------- |
| 实际场景 | Vue2 响应式              | Vue3 reactive           | Vue3 ref          |
| 优势     | 兼容性                   | 基于Proxy实现真正的拦截 | 实现简单          |
| 劣势     | 数组和属性删除等拦截不了 | 不兼容IE11              | 只拦截了value属性 |
| 实际应用 | Vue2                     | Vue3 复杂数据结构       | Vue3 简单数据结构 |





vue3中用计算属性代替过滤器（filter）

#### ref与reactive

1. 定义数据角度：

   ref：定义一个响应式的基本类型数据

   reactive：定义一个响应式的对象类型数据

   注意：ref也可以用于定义对象（数组）类型数据，在内部会自动通过reactive转化为代理对象

2. 响应式原理角度

   ref：响应式依然依靠Object.defineProperty()中的set()方法与get()方法实现

   reactive：响应式依靠Proxy代理源对象与Reflect反射操作源对象实现

3. 使用角度

   ref：操作数据需要加.value，在html模板中不需要加.value

   reactive：操作数据均不需要加.value

#### watchEffect与watch

1. 在options api(vue2)中我们采用watch来监听data中的数据或者props中的参数变化。在componsiton api(vue3)中我们采用watchEffect和watch来进行监听数据变化，并且watchEffect是自动收集依赖，watch则需要我们自己指定需要监听的数据。

2. watchEffect

   立即执行传入的一个函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。

   特性

   - `watchEffect`不需要指定监听的属性，他会自动的收集依赖， 只要我们回调中引用到了 响应式的属性， 那么当这些属性变更的时候，这个回调都会执行。
   - `watchEffect`必须立即执行一次(依赖收集)；注意: 依赖太多各种坑。
   - 可停止监听。

3. watch

   componsition api中的watch和options api中的watch一样，都是用来监听某一个属性发生变化，执行相关的回调。
   watchEffect和watch进行对比，watch是懒执行的(也就是说第一次不执行)。执行时会将newValue和oldValue传入函数。

   特性

   - 惰性地执行；

   - 更具体地说明应触发侦听器重新运行的状态；

   - 访问被侦听状态的先前值和当前值。

   - 可监听单个或多个源数据。

   - 默认不会立即执行。添加 `{ immediate:true }` 可以立即执行，没有惰性。

   - 不可以停止监听。

   - 添加第三个参数 `{deep: true}` 深度监听。

     

4. watchEffect 与 watch 有什么不同
   第一点我们可以从示例代码中看到 watchEffect 不需要指定监听的属性，他会自动的收集依赖， 只要我们回调中引用到了 响应式的属性， 那么当这些属性变更的时候，这个回调都会执行，而 watch 只能监听指定的属性而做出变更(v3开始可以同时指定多个)。
   第二点就是 watch 可以获取到新值与旧值（更新前的值），而 watchEffect 是拿不到的。
   第三点是 watchEffect 如果存在的话，在组件初始化的时候就会执行一次用以收集依赖（与computed同理），而后收集到的依赖发生变化，这个回调才会再次执行，而 watch 不需要，因为他一开始就指定了依赖。

5. watch与computed的区别

   computed可以更简洁地实现功能，watch则可以实现 一些特殊的功能，比如异步请求

   computed还具有缓存功能

6. 示例

   ```javascript
   import { ref, watch } from 'vue'
   export default {
   	setup() {
   	    // 直接侦听一个
   		const count = ref(0)
   		watch(count, (count, prevCount) => {
   		  /* ... */
   		}
   
   		// 直接侦听多个
   		const fooRef = ref(0);
   		const barRef = ref(0);
   		watch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) => {
   		  /* ... */
   		},{deep: true})
   	    return { count, fooRef, barRef }
   	}
   }
   
   
   
   //watchEffect
   import { ref, watchEffect } from 'vue'
   export default {
   	setup() {
   	    const count = ref(0)
   	    setInterval(() => {
         		count.value++
       	}, 1000)
       	 /** 这个hook用以监听count.value的变化 */
           watchEffect(() => console.log(count.value))
   	    // -> logs 0
   	    // -> logs 1
   	    // -> logs 2
   	    // -> logs 3
   	    // -> logs 4
   	    // -> logs ...
   	    return { count }
   	}
   }
   
   ```

   

##### 



#### getCurrentInstance



#### hooks

一、 什么是hooks

hook是钩子的意思，看到“钩子”是不是就想到了钩子函数？事实上，hooks 还真是函数的一种写法。

vue3 借鉴 react hooks 开发出了 Composition API ，所以也就意味着 Composition API 也能进行自定义封装 hooks。

vue3 中的 hooks 就是函数的一种写法，就是将文件的一些单独功能的js代码进行抽离出来，放到单独的js文件中，或者说是一些可以复用的公共方法/功能。其实 hooks 和 vue2 中的 mixin 有点类似，但是相对 mixins 而言， hooks 更清楚复用功能代码的来源, 更清晰易懂。

二、hooks的用法

1. 在src中创建一个hooks文件夹，用来存放hook文件

2. 根据需要写hook文件，比如要实现一个功能就是在 点击页面时，记录鼠标当前的位置，可以在hooks文件夹中新建一个文件useMousePosition.ts，

3. hook文件的使用：在需要用到该`hook`功能的组件中的使用，比如在 test.vue文件中

   

#### toRef和toRefs

**作用：toRef、toRefs用于将reactive内的节点提取出来，同时具有响应式结构。**

toRef 和 toRefs 可以用来复制 reactive 里面的属性然后转成 ref，而且它既保留了响应式，也保留了引用，也就是你从 reactive 复制过来的属性进行修改后，除了视图会更新，原有 ractive 里面对应的值也会跟着更新，如果你知道 浅拷贝 的话那么这个引用就很好理解了，它复制的其实就是引用 + 响应式 ref
不加 s 和 加 s 的区别就是这样：

toRef: 复制 reactive 里的单个属性并转成 ref
toRefs: 复制 reactive 里的所有属性并转成 ref

注意：

**toRef与toRefs都是将reactive的json内节点提取出来，做为独立的响应式结构。**

**二者的区别在于：toRef是指定某一节点提取出来，toRefs是一次性将所有节点提取出来。但toRefs只能提取一级节点！**

**toRefs返回的变量修改，与原始值无任何响应式关联。**

- template 要想访问 toRefs 的值，需要带上 `.value` 如果不带上，就会出现双引号。
- template 要想访问 toRef 的值，不需要带上 `.value`





#### shallowReactive和shallowRef

一，介绍
1.相对于ref和reactive，shallowRef 和shallowReactive创建的数据是浅响应式的

二，shallowRef介绍
1.shallowRef可以创建一个跟踪自身 .value 变化的 ref，但不会使其值也变成响应式的

2.当使用shallowRef为一个基础类型数据创建响应性时，行为是和ref一样的。

3.不同的是，当使用shallowRef为复杂类型创建响应性时，修改深层属性，不具备响应性

```javascript
const a = shallowRef({b:1})
a.value.b = 2  //视图不会更新
console.log(a.value) //{b : 2} 但是能追踪到值得变化

a.value={b:2} //一整个替换时，视图会变化
```

三，shallowReactive介绍
1.创建一个响应式代理，它跟踪其自身 property 的响应性，但不执行嵌套对象的深层响应式转换 (暴露原始值)

2.相对于reactive，shallowReactive只有最外层的属性是响应的

```javascript
const state = shallowReactive({
  foo: 1,
  nested: {
    bar: 2
  }
})

// 改变 state 本身的性质是响应式的
state.foo++
// ...但是不转换嵌套对象
isReactive(state.nested) // false
state.nested.bar++ // 非响应式
```

四，对数据进行非深度监听

我们发现无论写多少层数据；
数据层级有多深，ref始终会对数据进行深度监听。
这显然不是我们需要的。
我们迫切需要对数据进行非深度监听。
这个时候，我们就需要shallowReactive和shallowRef

对数据进行非深度监听，往往**可以提升数据的性能**





#### toRaw和markRaw

1. toRaw()函数


接收一个reactive响应式数据,将一个响应式的数据变为普通类型的数据,转化为非响应式数据,相当于还原对象,reactive相当于制作,但对于ref响应式数据不起作用

将一个由reactive生成的响应式对象转为普通(原始)对象

toRaw()可以返回由reactive(),readonly(),shallowReactive()或shallowReadonly()创建的代理对应的原始对象

这是一个可以用临时读取而不引起代理访问/跟踪开销,或是写入而不触发更改的特殊方法,在官方文档里,是不建议保存对原始对象的持久引用

使用场景:用于读取响应式对象的普通对象,对这个普通对象的所有操作,不会引起页面的更新

const foo = {}
const reactiveFoo = reactive(foo)
console.log(toRaw(reactiveFoo) === foo)  // true
注意

针对对象,后续动态新增的属性,如果没有把整个对象对外暴露出去,模板中使用新增的变量是不生效的(针对setup函数形式)



2. markRaw()函数

接收一个原始数据,标记一个对象,使它永远不会再成为响应式对象,也就是数据在逻辑中即使修改变化了,但是页面不会更新变化

将一个对象标记为不可被转为代理,返回该对象本身

应用场景:

[1]. 有些值不应该被设置为响应式的,例如复杂的第三方类库或Vue组件对象

[2]. 当渲染具有不可变数据源的大列表时,跳过响应式转换可以提高性能

const foo = markRaw({})
console.log(isReactive(reactive(foo))) // false
// 也适用于嵌套在其他响应性对象
const bar = reactive({ foo })
console.log(isReactive(bar.foo)) // false
markRaw()与shallowReactive()这样浅层式API使你可以有选择的避开默认的深度响应/只读转换,并在状态关系谱中嵌入原始,非代理的对象

如果把一个嵌套的,没有标记的原始对象设置成一个响应式对象,然后再次访问它,你获取到的是代理的版本,这可能会导致对象身份风险

即执行一个依赖于对象身份的操作,但却同时使用了同一对象的原始版本和代理版本

const foo = markRaw({
  nested: {}
})
const bar = reactive({
  // 尽管 `foo` 被标记为了原始对象，但 foo.nested 却没有
  nested: foo.nested
})
console.log(foo.nested === bar.nested) // false
总结
ref()与reactive()是将一个非响应式类型数据变为响应式数据,而toRaw()与markRaw()相当于是对响应式数据的还原,将一个响应式数据变为非响应式数据

而toRaw只针对响应式对象类型的数据起作用,如果涉及到将一个响应式数据转变为非响应式数据,只用于纯数据的渲染,不引起页面的更新,就可以使用toRaw或markRaw()

往往**可以提升数据的性能**






#### Teleport



------

### 从0到1搭建Vue项目

1. 搭建开发环境（node、vue-cli或vite）
2. 了解项目需求
3. vue create my-app或npm create vite



## webpack

1. webpack的作用是什么，谈谈你对它的理解？

   现在的前端网页功能丰富，特别是SPA（single page web application 单页应用）技术流行后，JavaScript的复杂度增加和需要一大堆依赖包，还需要解决Scss，Less……新增样式的扩展写法的编译工作。

   所以现代化的前端已经完全依赖于webpack的辅助了。

   现在最流行的三个前端框架，可以说和webpack已经紧密相连，框架官方都推出了和自身框架依赖的webpack构建工具。

   react.js+WebPack

   vue.js+WebPack

   AngluarJS+WebPack

2. webpack的工作原理?

   WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Sass，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。在3.0出现后，Webpack还肩负起了优化项目的责任。

3. webpack打包原理

   把一切都视为模块：不管是 css、JS、Image 还是 html 都可以互相引用，通过定义 entry.js，对所有依赖的文件进行跟踪，将各个模块通过 loader 和 plugins 处理，然后打包在一起。

   按需加载：打包过程中 Webpack 通过 Code Splitting 功能将文件分为多个 chunks，还可以将重复的部分单独提取出来作为 commonChunk，从而实现按需加载。把所有依赖打包成一个 bundle.js 文件，通过代码分割成单元片段并按需加载

4. webpack的核心概念

   Entry：入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。告诉webpack要使用哪个模块作为构建项目的起点，默认为./src/index.js

   output ：出口，告诉webpack在哪里输出它打包好的代码以及如何命名，默认为./dist

   Module：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。

   Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。

   Loader：模块转换器，用于把模块原内容按照需求转换成新内容。

   Plugin：扩展插件，在 Webpack 构建流程中的特定时机会广播出对应的事件，插件可以监听这些事件的发生，在特定时机做对应的事情。

5. Webpack的基本功能有哪些？

   代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等等

   文件优化：压缩 JavaScript、CSS、html 代码，压缩合并图片等

   代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载

   模块合并：在采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件

   自动刷新：监听本地源代码的变化，自动构建，刷新浏览器

   代码校验：在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过

   自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。

6. gulp/grunt 与 webpack的区别是什么?

   三者都是前端构建工具，grunt和gulp在早期比较流行，现在webpack相对来说比较主流，不过一些轻量化的任务还是会用gulp来处理，比如单独打包CSS文件等。grunt和gulp是基于任务和流（Task、Stream）的。

   类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。webpack是基于入口的。

   webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。

7. webpack是解决什么问题而生的?

   如果像以前开发时一个html文件可能会引用十几个js文件,而且顺序还不能乱，因为它们存在依赖关系，同时对于ES6+等新的语法，less, sass等CSS预处理都不能很好的解决……，此时就需要一个处理这些问题的工具。







## vite

### 

vite核心原理 (下面三条必会）

- Vite其核心原理是利用浏览器现在已经支持ES6的import，碰见import就会发送一个HTTP请求去加载文件。

- Vite整个过程中没有对文件进行打包编译，做到了真正的按需加载，所以其运行速度比原始的webpack开发编译速度快出许多！

  特点：

- 快速的冷启动：基于Esbuild的依赖进行预编译优化 （Esbuild 打包速度太快了，比类似的工具快10~100倍 ）

- 增加缓存策略：源码模块使用协商缓存，依赖模块使用强缓；因此一旦被缓存它们将不需要再次请求。

-  HMR（热更新）：当修改代码时，HMR 能够在不刷新页面的情况下，把页面中发生变化的模块，替换成新的模块，同时不影响其他模块的正常运作

- 基于 Rollup 打包：生产环境下由于esbuild对css和代码分割并使用Rollup进行打包；

- 高效的热更新：基于ESM实现，同时利用HTTP头来加速整个页面的重新加载



### vite3创建vue3多环境配置

场景需求：平时业务开发中，在各阶段中都会有不同的运行环境，常用的我们就有开发环境、测试环境、生产环境 ，这就使到我们要对vue3项目做环境拆分

1. 在项目根目录下创建不同的环境变量文件，以便于在项目中引用

<img src="https://cdn.staticaly.com/gh/zhixi0912/blog.github.io@master/images/summarize/image-20221217030606004.1nam8ldy7izk.webp" alt="image-20221217030606004" style="zoom:50%;" />

2. 在文件中写于环境变量

   ```javascript
   ## 开发环境 .env.development
   
   # 变量必须以 VITE_ 为前缀才能暴露给外部读取
   NODE_ENV='development'
   
   VITE_APP_TITLE = 'collect-infor-admin'
   VITE_APP_PORT = 8080
   VITE_APP_BASE_API = '/dev-api'
   VITE_APP_BASE_URL = 'http://127.0.0.1:5000'
   
   
   ## 测试环境	.env.uat
   
   # 变量必须以 VITE_ 为前缀才能暴露给外部读取
   NODE_ENV='uat'
   
   VITE_APP_TITLE = 'collect-infor-admin'
   VITE_APP_PORT = 8090
   VITE_APP_BASE_API = '/uat-api'
   VITE_APP_BASE_URL = 'http://127.0.0.1:5000'
   
   
   ## 生产环境	.env.production
   NODE_ENV='production'
   
   VITE_APP_TITLE = 'collect-infor-admin'
   VITE_APP_PORT = 80
   VITE_APP_BASE_API = '/prod-api'
   VITE_APP_BASE_URL = 'http://10.0.12.8:9500'
   ```

   

3. 配置vite.config.ts文件

   ```javascript
   import { fileURLToPath, URL } from 'node:url'
   import { defineConfig, loadEnv } from 'vite'
   import vue from '@vitejs/plugin-vue'
   
   // https://vitejs.dev/config/
   export default defineConfig(({mode}) => {
     const env = loadEnv(mode, process.cwd(), '')
     return {
       plugins: [vue()],
       resolve: {
         alias: {
           '@': fileURLToPath(new URL('./src', import.meta.url)),
           'pub': fileURLToPath(new URL('./public', import.meta.url))
         }
       },
       // baseUrl: process.env.NODE_ENV === 'production' ? './' : '/',
       // 本地反向代理解决浏览器跨域限制
       server: {
         host: '127.0.0.1',
         port: Number(env.VITE_APP_PORT),
         open: true, // 运行自动打开浏览器
         proxy: {
           [env.VITE_APP_BASE_API]: {
             target: env.VITE_APP_BASE_URL,
             changeOrigin: true,
             rewrite: path =>
               path.replace(new RegExp('^' + env.VITE_APP_BASE_API), '')
           }
         }
       },
       // 打包时去掉项目中的消息打印和断点
       // build: {
       //   terserOptions: {
       //     compress: {
       //       drop_console: true,
       //       drop_debugger: true
       //     }
       //   }
       // }
     }
   })
   
   ```

   

4. 配置axios请求中的baseURL

   ```javascript
   //utils/request.ts
   import axios from "axios";
   
   const service = axios.create({
       baseURL: import.meta.env.VITE_APP_BASE_API,
       timeout: 5000,
       headers: { 'Content-Type': 'application/json;charset=utf-8' }
   })
   
   service.interceptors.request.use(config => {
   ...
   ```

   

### vite自动添加浏览器前缀

我们知道 `postcss` 可以对某些 `css` 属性（比如 `user-select`）自动添加浏览器前缀。那么 `Vite` 会自动帮我们添加浏览器前缀吗？我们来测试一下，在 `src/css/title.less` 文件中添加 `user-select: none;` 这行代码：

```
@fontSize: ``30px``;``@fontColor: yellow;``.title {`` ``font-size``: @fontSize;`` ``color``: @fontColor;`` ``user-select: ``none``; // 添加 user-select 属性，测试浏览器前缀是否有添加``}
```

然后我们看下浏览器中的效果：

![img](https://cdn.staticaly.com/gh/zhixi0912/blog.github.io@master/images/summarize/j-001.sxo0tcqqyf4.png)

可见，`Vite` 默认情况下是不会帮我们给 `css` 属性添加浏览器前缀的。那如果我们想让它帮我们自动添加该怎么做呢？那么，我们可以先来安装一下 `postcss` 工具：

```
npm ``install` `postcss -D
```

安装完 `postcss` 后，再来执行 `npx vite` 把项目跑起来，再来看效果：

![img](https://cdn.staticaly.com/gh/zhixi0912/blog.github.io@master/images/summarize/j-002.6uyfha0m8w80.png)

还是没有效果，这是为什么？因为我们说过，`postcss` 是需要依赖对应的插件来帮助我们实现对应的功能的，所以，我们这里可以安装一下 `postcss-preset-env` 插件（或者 `autoprefixer` 插件，但现在 `postcss-preset-env` 用得更多）：

```
npm ``install` `postcss-preset-``env` `-D
```

安装好之后，还需要配置 `postcss`，我们可以在项目目录下新建 `postcss.config.js` 文件，内容如下：

```
module.exports = {`` ``plugins: [``  ``require(``'postcss-preset-env'``)`` ``]``}
```

注意：在使用 `Webpack` 时 `postcss` 配置插件这边可以直接传入字符串，但 `Vite` 这边不行，如果不通过 `require()` 导入插件，而是直接传字符串：

```
module.exports = {`` ``plugins: [``  ``'postcss-preset-env'`` ``]``}
```

启动项目会报错：

![img](https://cdn.staticaly.com/gh/zhixi0912/blog.github.io@master/images/summarize/j-003.6vp0jsw6b9k0.png)

然后再来执行 `npx vite` 命令启动项目，浏览器中查看效果：

![img](https://cdn.staticaly.com/gh/zhixi0912/blog.github.io@master/images/summarize/j-004.pcaa4orhtjk.png)

可以看到，这次就有加上浏览器前缀了。



## GIT

### git常用命令

1. git init 初始化git仓库 (mac中Command+Shift+. 可以显示隐藏文件)

2. git status 查看文件状态

3. git add 文件列表 追踪文件

4. git commit -m 提交信息 向仓库中提交代码

5. git log 查看提交记录

1.分支明细

（1）主分支（master）：第一次向 git 仓库中提交更新记录时自动产生的一个分支。

（2）开发分支（develop）：作为开发的分支，基于 master 分支创建。

（3）功能分支（feature）：作为开发具体功能的分支，基于开发分支创建

2.分支命令

（1）git branch 查看分支

（2）git branch 分支名称 创建分支

（3）git checkout 分支名称 切换分支

（4）git merge 来源分支 合并分支 (备注：必须在master分支上才能合并develop分支)

（5）git branch -d 分支名称 删除分支（分支被合并后才允许删除）（-D 强制删除）

3.暂时保存更改

（1）存储临时改动：git stash

（2）恢复改动：git stash pop



### **git怎么解决多人冲突？**

> 是当前修改是左箭头方向，传入的是右箭头的方向，
>
> **中间用等于号分割，等号上边是当前修改（本地），下边是传入的修改（线上的代码）。**
>
> 两人同时提交可能会出现冲突，解决办法是手动修改冲突









##  JAVA基础



```java
//常用快捷代码
// psvm
public static void main(String[] args) {}

//sout
System.out.println();

//javaDoc生成文档
javadoc -encoding UTF-8 -charset UTF-8 Doc.java
```



```java
package target;

public class Demo06 {
    // 类变量 可直接使用
    static double salary = 2500;

    //属性变量 必须new后使用
    String name;
    int age;

    public static void main(String[] args) {
        int i = 10;
        System.out.println(i);
        // 变量类型 变量名 = new target.Demo06();
        Demo06 demo06 = new Demo06();
        System.out.println(demo06.age);
        System.out.println(demo06.name);

        System.out.println(salary);
    }
}
```



### java流程控制

- Scanner

  如何使用Scanner

  ```java
  import java.util.Scanner;
  ...
  //创建一个扫描器对象，用于接收键盘输入的数据
  Scanner scanner = new Scanner(System.in);
  ...
  scanner.close();
  
  ```

  1. scanner.next() // 获取一段输入
  2. scanner.hasNext() //判断是否有输入
  3. scanner.nextLine() //获取一行输入
  4. scanner.hasNextLine() //判断是否有输入
  5. scanner.nextInt()
  6. scanner.hasNextFloat()
  7. scanner.nextDouble()

- ...





























## Python基础

### 元组

### 字典

### Class 类

### 面向对象

## Python 进阶





```javascript
 "dev": "vite preview --mode development",
 "build": "run-p type-check build-only --mode development",
 "build:p": "run-p type-check build-only --mode production",
 "build:t": "run-p type-check build-only --mode text",
 "preview": "vite preview",
 "build-only": "vite build",
 "type-check": "vue-tsc --noEmit"
```



## Python flask



### 变量规则



```python
from markupsafe import escape

@app.route('/user/<username>')
def show_user_profile(username):
    # 显示该用户的用户个人资料
    return f'User {escape(username)}'

@app.route('/post/<int:post_id>')
def show_post(post_id):
    # 显示给定id的帖子，id是一个整数
    return f'Post {post_id}'

@app.route('/path/<path:subpath>')
def show_subpath(subpath):
    # 在 /path/ 之后显示子路径
    return f'Subpath {escape(subpath)}'
```



### http方法

```python
#	默认路由仅响应 GET 请求。可以使用 route() 装饰器的方法参数来处理不同的 HTTP 方法

from flask import request

@app.route('/login',methods=['GET','POST'])
def login():
    if request.method == 'POST':
        return do_the_login()
    else:
        return show_the_login_form()
#	您还可以将不同方法的视图分成不同的函数。Flask 为每个常见的 HTTP 方法提供了一种快捷方式，用于使用 get()、post() 等来装饰此类路由

@app.get('/login')
def login_get():
    return show_the_login_form()

@app.post('/login')
def login_post():
    return do_the_login()
```





















## Mysql

### mysql连接2059

报错原因是caching_sha2_password不能加载。

这是因为8.0之后mysql更改了密码的加密规则，而目前已有的客户端连接软件还不支持Mysql8新增加的加密方式caching_sha2_password，所以我们需要修改用户的加密方式，将其改为老的加密验证方式。



<img src="https://cdn.staticaly.com/gh/zhixi0912/blog.github.io@master/images/summarize/image-20221219073855531.2p5cxznp1200.png" alt="image-20221219073855531" style="zoom:33%;" />



1. 打开终端

2. 登陆数据库：输入mysql -uroot -p

3. 输入你的数据库密码，正确后显示登陆成功 出现Welcome to the MySQL monitor.

4. 输入use mysql; 出现Database changed

5. 输入select user,host from user; 目的为了查看user的root 对应host是什么 我的对应为localhost

6. 输入alter user root@localhost identified by 'password' password expire never;来修改加密规则。

7. 修改加密规则：输入ALTER USER ‘root’@‘localhost’ IDENTIFIED WITH mysql_native_password BY ‘root’;

   注:第一个root为数据库用户名 第二个root为数据库密码 切记换成自己的用户名和密码

8. 如果你查看到的root对应的host为% ，将该句改成ALTER USER ‘root’@‘%’ IDENTIFIED WITH mysql_native_password BY ‘root’;

9.	输入flush privileges，刷新数据库

10. 点击连接测试，或者双击Navicat对应的MySQL即可成功

    <img src="https://cdn.staticaly.com/gh/zhixi0912/blog.github.io@master/images/summarize/image-20221219075709677.17pyoyi1fxsw.webp" alt="image-20221219075709677" style="zoom:50%;" />

<img src="https://cdn.staticaly.com/gh/zhixi0912/blog.github.io@master/images/summarize/image-20221219075146583.4hvt02mnlcm0.webp" alt="image-20221219075146583" style="zoom:50%;" />













## Linix

> 规划Linux用户目录结构

```shell
├── bin
├── boot
├── home
├── ...
└── root
    └── project
    		├── vue_blogs
        │	  └── nginx
        ├── vue_admin
        │	  └── nginx
        ├── python_blogs
        │	  ├── redis
        │   └── mysql
        ├── python_admin
        │	  ├── redis
        │   └── mysql
        ├── java_admin
        │	  ├── redis
        │   └── mysql
        ├── react
        └── app
```



## docker

### 部署Nginx服务

> 准备工作

准备好静态html文件。如vue、react等项目打包后的文件

1. 创建挂载目录

   使用shell等工具连接到linux服务器。

   ```shell
   # 目录结构
   └── root
       └── vue_admin
       	 └── nginx
              ├── html
              └── conf
   
   ssh root@ 192.168.*.*
   password:****
   cd /root
   mkdir vue_admin
   cd vue_admin
   mkdir nginx
   cd nginx
   mkidr html
   mkdir conf
   
   docker search nginx # 查找nginx镜像
   docker pull nginx    # 下载nginx镜像
   docker images     # 查看下载的镜像中是否有nginx
   ```

   <img src="https://cdn.staticaly.com/gh/zhixi0912/blog.github.io@master/images/summarize/image-20221216011905380.14940ax1c9ts.webp" alt="image-20221216011905380" style="zoom:50%;" />

2. 创建一个临时nginx容器，复制出它的配置文件和目录结构

   ```shell
   docker run -d --name nginx2 nginx
   docker ps -a
   docker cp nginx2:/etc/nginx/nginx.conf /root/vue_admin/nginx/conf
   docker cp nginx2:/etc/nginx/conf.d /root/vue_admin/nginx
   # 有可能复制后在目录中找不到这俩文件，但是过段时间后又出现了（linux执行copy也这么慢吗）
   docker stop nginx2
   docker rm nginx2
   # 文件复制好后，停掉这个nginx容器，然后删除掉它，
   ```

   

   ![image-20221216014824288](https://cdn.staticaly.com/gh/zhixi0912/blog.github.io@master/images/summarize/image-20221216014824288.40gl8im4urc0.webp)

   ![image-20221216015019115](https://cdn.staticaly.com/gh/zhixi0912/blog.github.io@master/images/summarize/image-20221216015019115.1hdxoedhokbk.webp)

   <img src="https://cdn.staticaly.com/gh/zhixi0912/blog.github.io@master/images/summarize/image-20221216022227738.1p0juvhv7zds.webp" alt="image-20221216022340148" style="zoom:50%;" />

   

   

3. 根据配置好的目录和文件，创建Nginx容器

   ```shell
   docker run --name vue_admin -p 8101:80 -d -v /root/vue_admin/nginx/html:/usr/share/nginx/html -v /root/vue_admin/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /root/vue_admin/nginx/conf/conf.d:/etc/nginx/conf.d  nginx
   #	-d ：使容器在后台运行
   #	-p ：端口映射，即访问本机的前者(8101)相当于访问docker容器中的后者(80)
   # -v ：将nginx的nginx.conf和conf.d分别挂载到宿主机目录上【特别要注意，如果宿主机上没有这些目录或名字写错或文件弄错，就会创建失败会疯狂报错并启动失败，只能删掉重建】
   
   Error response from daemon: oci runtime error: container_linux.go:290: starting container process caused "container init exited prematurely".
   
   Error response from daemon: oci runtime error: container_linux.go:290: starting container process caused "container init exited prematurely"
   Error: failed to start containers: vue_admin
   
   # 创建容器成功后，以后要修改Nginx配置项，只要去宿主机root/vue_admin/nginx/conf里边的文件就可以了
   
   docker exec vue_admin nginx -t	# 测试配置文件
   docker exec vue_admin nginx -s reload		# 重新加载配置文件
   ```

   ![image-20221216022506387](https://cdn.staticaly.com/gh/zhixi0912/blog.github.io@master/images/summarize/image-20221216022506387.5zs4xwvh6340.webp)

   

4. 服务器防火墙开启Nginx映射的端口8101

   ![image-20221216023520132](https://cdn.staticaly.com/gh/zhixi0912/blog.github.io@master/images/summarize/image-20221216023520132.1a8g9y7uo9uo.webp)

   > 此时就可以去浏览器输入：公网IP:8101，就可以访问Nginx窗口啦

   ![image-20221216023854701](https://cdn.staticaly.com/gh/zhixi0912/blog.github.io@master/images/summarize/image-20221216023854701.2r96d6tjzsi0.webp)

   

5. 配置Nginx服务

   此时只是能访问静态文件，但是接口服务没有作代理，还是会报404错误，因此，我们还要对/root/vue_admin/nginx/conf目录下的文件进行配置。

   <img src="https://cdn.staticaly.com/gh/zhixi0912/blog.github.io@master/images/summarize/image-20221216024443396.45kpu00p5ue0.webp" alt="image-20221216024443396" style="zoom:50%;" />

   

   配置文件有2种方法，一是通过shell工具直接在线操作服务器上的文件；二是将文件下载到本地，配置好后上传覆盖

   这里我使用第二种方法，以下贴出详细文件配置项

### 部署Python服务

1. 创建docker容器

   ```shell
   docker run -it -d --name=py_dome -p 9600:5000 -v /root/python/demo:/root/project --net mynet --ip 172.18.0.3 python:3.9.6 bash
   docker exec -it py_dome bash
   pip install flask -i https://pypi.tuna.tsinghua.edu.cn/simple
   ```

2. 创建环境依赖文件

   ```
   pip freeze > requirements.txt
   ```

   

3. 将Python文件打包成.pyc文件

   ```shell
   python3 -m compileall -b /Users/myMacbook/work/build/flask-dome
   # app.run(host='0.0.0.0')
   ```

   > -m: 当前目录下所有文件
   > -b: 编译后的文件放在当前目录下

4. 主目录下创建Dockerfile文件

   ```shell
   	FROM python:3.9.6      # 基础镜像-python的版本
   	WORKDIR /usr/src/app	# 工作路径
   	COPY requirements.txt ./	# 复制文件到容器中
   	RUN pip install --no-cache-dir -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple # 下载依赖包
   	COPY . .
   	CMD [ "python", "./app.py" ]   # 启动容器时自动执行的命令，我的flask启动命令写在app.py函数里，所以这里我直接去运行此文件 使容器一运行我的flask项目也开始运行
   ```

5. 打包docker镜像文件，创建docker容器并运行镜像文件

   ```shell
   docker build -t flaskdemo . 
   #	-t ：指定要创建的目标镜像名
   #	. ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径
   docker run -d -p 127.0.0.1:6200:5000 --name mydemo1 flaskdemo
   #	-d ：使容器在后台运行
   #	-p ：端口映射，即访问本机的前者(6200)相当于访问docker容器中的后者(5000)
   curl 127.0.0.1:9500
   nohup python app.py > los.txt
   # 启动python程序后仍不能访问请检查下面条件
   app.run(host='0.0.0.0')
   ```

   
