# 技术归纳



## 数据结构

### 栈和堆

1. 什么是栈和堆

   - 栈(stack)：栈会自动分配内存空间，会自动释放，存放基本类型，简单的数据段，占据固定大小的空间。

   基本类型：String，Number，Boolean，Null，Undefined

   - 堆(heap)：动态分配的内存，大小不定也不会自动释放，存放引用类型，指那些可能由多个值构成的对象，保存在堆内存中，包含引用类型的变量，实际上保存的不是变量本身，而是指向该对象的指针。

     引用类型：Function，Array，Object

2. 两者区别区

   - 栈：所有在方法中定义的变量都是放在栈内存中，随着方法的执行结束，这个方法的内存栈也自然销毁。

     优点：存取速度比堆快，仅次于直接位于CPU中的寄存器，数据可以共享；

     缺点：存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。

   - 堆：堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用(参数传递)。创建对象是为了反复利用，这个对象将被保存到运行时数据区。

​		栈内赋值(a=[],b=a)都是变量在栈中对堆地址引用，当a内容改变时，b也会跟着改变，这就是**浅拷贝**

​		当栈内赋值的同时，也为赋值对象b在堆中创建一个新的内存地址，那么当a改变时，b则因为引用堆地址不同而不变，这就是**深拷贝**

3.	溢出
如果想要堆溢出，比较简单，可以循环创建对象或大的对象；
如果想要栈溢出，可以<u>**递归调用**</u>方法，这样随着栈深度的增加，JVM（虚拟机）维持着一条长长的方法调用轨迹，直到内存不够分配，产生栈溢出。

JavaScript堆不需要程序代码来显示地释放，因为堆是由自动的垃圾回收来负责的，每种浏览器中的JavaScript解释引擎有不同的自动回收方式，但一个最基本的原则是：如果栈中不存在对堆中某个对象的引用，那么就认为该对象已经不再需要，在垃圾回收时就会清除该对象占用的内存空间。因此，在不需要时应该将对对象的引用释放掉（解除引用），以利于垃圾回收，这样就可以提高程序的性能。释放对对象的引用最常用的方法就是为其赋值为null，这种做法适用于大多数全局变量和全局对象的属性。局部变量会在他们离开执行环境时自动被解除引用。

注意：解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。

4.	关于垃圾回收机制
javascript的解析器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。

```javascript
var a = "hello world";
var b = "world";
var a = b;
// 这时，会释放掉“hello world”，释放内存以便再引用
```







## 算法基础



### 二分查找法



### 冒泡排序法









## 前端基础

### Javascrpit基础知识点

#### 数据类型【8种】

**Number、String、Boolean、undefined、object、Null、Symbol、bigInt（谷歌定义的，一般不算内）**

【Object是个大类，function函数、array数组、date日期...等都归属于Object】

判断数据类型

1. **typeof**

2. **instanceof**

3. **Object.prototype.toString.call()**

   `Object.prototype.toString.call(val) === '[object Object]' // true 代表为对象`

   `Object.prototype.toString.call(val) === '[object Array]' // true 代表为数组`

   *[object Function]*、*[object Date]*、*[object RegExp]*

4. **Object.getPrototypeOf()**

   `Object.getPrototypeOf(val) === Object.prototype // true 代表为对象`

   `Object.getPrototypeOf(val) === Array.prototype *// true 代表为数组*`

5. **constructor**

6. **toString**

7. **Array.isArray() **

   `Array.isArray(val) // true 代表为数组`

   ```javascript
   function typeOf(obj){
   	return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase()
   }
   
   typeOf([])
   ```

   

#### 对象

扩展运算符： 扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。

枚举属性for in： 循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性），自身属性或者来自原型对象上的继承属性都可以被枚举出来。

Object.create()：创建一个对象（const obj = Object.create({a:1}, {b: {value: 2}})）

Object.assign()： 将所有可枚举属性的值从一个或多个源对象分配到目标对象并返回目标对象,常用来合并对象。 Object.assign(target, …sources)。 参数解析： target—>目标对象，source—>源对象，返回值是target，即目标对象。

Object.keys(obj)： 返回obj对象所有的可枚举的自有属性的名称组成的数组，不包含继承属性。

Object.values()： 返回一个给定对象自身的所有可枚举属性值的数组

Object.entries()： 返回一个给定对象自身可枚举属性的键值对组成的数组

Object.freeze()： 可以冻结一个对象，冻结后不能做任何操作。

hasOwnProperty()： 返回一个布尔值，用于检测这个属性是否是对象本身属性，而不是原型对象上的属性。obj.hasOwnProperty(‘name’))

Object.getOwnPropertyNames(obj)： 返回一个自身所有属性(可枚举和不可枚举属性)名称组成的字符串数组,但是不含 Symbol 属性。

Object.getOwnPropertySymbols(obj)： 返回一个数组，包含对象自身的所有 Symbol 属性的键名。









#### 数组

1. push() 将一个或多个元素添加到数组的末尾，并返回该数组的新长度。此方法修改原有数组。

  ```
  var arr = ['a','b','c'];
  var ele = arr.push('d');
  // ele结果为: 4;
  // arr数组被修改: ['a','b','c','d'];
  
  ```

  

2. pop()，从数组中删除最后一个元素，并返回该元素的值。如果数组为空，则返回undefined。此方法修改原有数组。

  ```
  var arr = ['a','b','c','d'];
  var ele = arr.pop();
  // ele结果为: 'd';
  // arr数组被修改: ['a','b','c'];
  
  ```

  

3. shift()，从数组中删除第一个元素，并返回该元素的值。此方法修改原有数组。

  ```
  var arr = ['a','b','c','d'];
  var ele = arr.shift();
  // ele结果为: a;
  // arr数组被修改: ['b''c','d'];
  
  ```

  

4. unshift()，将一个或多个元素添加到数组的开头，并返回该数组的新长度。此方法修改原有数组。

  ```
  var arr = ['a','b','c'];
  var ele = arr.unshift('d');
  // ele结果为: 4;
  // arr数组被修改: ['d','a','b','c'];
  
  ```

  

5. slice(begin,end)，返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。
begin 可选 提取起始处的索引（从0开始），从该索引开始提取原数组元素
如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取，slice(-2) 表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。
如果省略 begin，则 slice 从索引 0 开始。
如果 begin 超出原数组的索引范围，则会返回空数组。

end 可选 提取终止处的索引（从 0 开始），在该索引处结束提取原数组元素。slice 会提取原数组中索引从 begin 到 end 的所有元素（包含 begin，但不包含 end）。
slice(1,4) 会提取原数组中从第二个元素开始一直到第四个元素的所有元素 （索引为 1, 2, 3的元素）。
如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取。 slice(-2,-1) 表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。
如果 end 被省略，则 slice 会一直提取到原数组末尾。
如果 end 大于数组的长度，slice 也会一直提取到原数组末尾。

```
var arr = ['a','b','c','d'];
var res = arr.slice(0,2);
// arr数组未被修改: ['a', 'b', 'c', 'd'];
// res数组为: ['a', 'b'];

```


6. splice(start,deleteCount?,item1?) ，通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容（如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组）。此方法修改原数组。
start：
指定修改的开始位置（从0计数）。如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位开始的第几位（从-1计数，这意味着-n是倒数第n个元素并且等价于array.length-n）；如果负数的绝对值大于数组的长度，则表示开始位置为第0位。

deleteCount (可选)：
整数，表示要移除的数组元素的个数。
如果 deleteCount 大于 start 之后的元素的总数，则从 start 后面的元素都将被删除（含第 start 位）。
如果 deleteCount 被省略了，或者它的值大于等于array.length - start(也就是说，如果它大于或者等于start之后的所有元素的数量)，那么start之后数组的所有元素都会被删除。
如果 deleteCount 是 0 或者负数，则不移除元素。这种情况下，至少应添加一个新元素。

item1, item2, … （可选）：
要添加进数组的元素,从start 位置开始。如果不指定，则 splice() 将只删除数组元素。

```javascript
var arr = ['a', 'b', 'c', 'd'];
// 从索引 2 的位置开始删除 0 个元素，插入"e"
var insertOnce = arr.splice(2,0,'e');
insertOnce = []
arr = ['a', 'b', 'e', 'c', 'd']
// 从索引3的位置开始删除一个元素
var delOnce = arr.splice(3,1);
// delOnce数组为: ['c']
// arr数组被修改: ['a', 'b', 'e', 'd']

```


7. concat()，于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。

  ```
  var arr1 = ['a', 'b', 'c', 'd'];
  var arr2 = ['e','f']
  var arr3 = arr1.concat(arr2);
  // arr3数组为: ['a', 'b', 'c', 'd','e','f']
  
  ```

  

8. join()，将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符(默认使用’,'分隔，如果使用""，则所有元素之间都没有任何字符)。

  ```
  var arr = ['a','b','c','d'];
  var str = arr.join("-")
  // str结果为: "a-b-c-d"
  
  ```

  

9. sort()，对数组的元素进行排序。此方法修改原数组。

  ```
  var arr = [1,5,2,4,3]
  arr.sort()
  // arr数组被修改: [1,2,3,4,5]
  
  ```

  

10. reverse()，将数组中元素的位置颠倒，并返回该数组。数组的第一个元素会变成最后一个，数组的最后一个元素变成第一个。该方法修改原数组。

    ```
    var arr = [1,2,3,4,5];
    arr.reverse();
    // arr数组被修改: [5,4,3,2,1]
    
    ```

    

11. forEach(function(currentValue，index?,array?),thisValue?)，对数组的每个元素执行一次给定的函数。
currentValue 必选 当前元素的值

index 可选 当前元素的索引值

array 可选 当前元素属于的数组对象

thisValue 可选 执行callback函数时值被用作 this。如果省略或传入null,undefined那么callback函数的this为全局对象

```
function logArrayElements(element, index, array) {
  console.log('a[' + index + '] = ' + element);
}

// 注意索引 2 被跳过了，因为在数组的这个位置没有项
[2, 5, , 9].forEach(logArrayElements);
// logs:
// a[0] = 2
// a[1] = 5
// a[3] = 9

```



12. map(function(currentValue，index?,array?),thisValue?)，创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。

    ```javascript
    // 使用 map 重新格式化数组中的对象
        var kvArray = [{key: 1, value: 10},
                   {key: 2, value: 20},
                   {key: 3, value: 30}];
    
    var reformattedArray = kvArray.map(function(obj) {
       var rObj = {};
       rObj[obj.key] = obj.value;
       return rObj;
    });
    
    // reformattedArray 数组为： [{1: 10}, {2: 20}, {3: 30}],
    
    // kvArray 数组未被修改:
    // [{key: 1, value: 10},
    //  {key: 2, value: 20},
    //  {key: 3, value: 30}]
    
    
    ```
    
    



13. filter(function(currentValue,index,arr), thisValue)，创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。

    ```
    // 筛选出字符串数组中长度大于6的字符串
    const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];
    
    const result = words.filter(word => word.length > 6);
    
    console.log(result);
    // log: ["exuberant", "destruction", "present"]
    
    ```

    

14. every(function(currentValue,index,arr), thisValue)，测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值(若收到一个空数组，此方法在一切情况下都会返回 true)。

    ```
    // 检查是否数组中的所有数字都小于40
    const isBelowThreshold = (currentValue) => currentValue < 40;
    
    const array1 = [1, 30, 39, 29, 10, 13];
    
    console.log(array1.every(isBelowThreshold));
    // log: true
    ```

    


15. some(function(currentValue,index,arr), thisValue)，测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值(如果用一个空数组进行测试，在任何情况下它返回的都是false)。
    

    ```
    //  检测数组中是否至少有一个数字大于 18:
        var ages = [3, 10, 18, 20];
    
    function checkAdult(age) {
        return age >= 18;
    }
    
    function myFunction() {
        document.getElementById("demo").innerHTML = ages.some(checkAdult);
    }
    ```

    

16. find(function(currentValue,index,arr), thisValue)，返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。

    ```
     // 获取数组中第一个大于10的值
    const array1 = [5, 12, 8, 130, 44];
    
    const found = array1.find(element => element > 10);
    
    console.log(found);
    // expected output: 12
    ```

    

17. flat(depth?)，按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。此方法不会改变原数组。
depth 可选 指定要提取嵌套数组的结构深度，默认值为 1。

```javascript
const arr1 = [0, 1, 2, [3, 4]];

console.log(arr1.flat());
// log: [0, 1, 2, 3, 4]

const arr2 = [0, 1, 2, [[[3, 4]]]];

console.log(arr2.flat(2));
// log: [0, 1, 2, [3, 4]]
```

18. reduce

    语法：arr.**reduce**(**callback**(accumulator, currentValue, index, array), initialValue)

    ```javascript
    //求和
    let sum = [1, 2, 3, 5].reduce((acc, current) => {
     return acc + current 
    }, 0)
    
    
    //数组去重
    let arr = ['1', '2', '2', '3', '4'].reduce((acc, cur) => {
      if (!acc.includes[cur]) {
        return acc.concat(cur)
      }
      return acc
    }, [])
    // 当然还可以使用new set 
    // Array.from 从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。
    Array.from(new Set(myArray))
    
    
    //多维数组扁平化
    let arr1 = [[0, 1], [2, 3], [4, [5, 6, 7]]]
    const flattenArr = function (arr) {
      return arr.reduce((acc, cur) => {
        return acc.concat(Array.isArray(cur) ? flattenArr(cur) : cur)
      }, [])
    }
    console.log(flattenArr(arr1))
    
    
    //多维数组扁平化
    let arr = [1,[2,[3,[4,5]]],[6,[7,[8,9]]]]
    let newArr = []
    const decending = (arr) => {
      if (arr === null) {
        return arr
      }
      arr.forEach((item)=>{
        if(Array.isArray(item)){
          decending(item)
        }else{
          newArr.push(item)
        }
      })
    }
    
    decending(arr)
    console.log(newArr)
    
    ```

    

19. 







#### websocket

后端地址是http的  [websocket](https://so.csdn.net/so/search?q=websocket&spm=1001.2101.3001.7020)地址 ws开头；后端地址是https的，websocket地址wss开头；

对于websocket没有[跨域](https://so.csdn.net/so/search?q=跨域&spm=1001.2101.3001.7020)的问题

**1.什么是WebSocket**

HTML5规范提供的一种浏览器与服务器进行全双工通讯的网络技术，它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。

**2.优点**

相对于http协议来说

1. 支持双向通信
2. 使用简单，只需要在浏览器中调用api就能完成协议切换
3. 支持扩展，可以在协议中实现自定义的子协议
4. 头部开销小，可以在网络中更快的传输

```javascript
import { MessageBox } from 'element-ui';
let url = "ws://192.168.0.181:8000";  //请求的后端地址
 
let websocket = null;//全局WebSocket对象
let lockReconnect = false; // 网络断开重连
let wsCreateHandler = null; // 创建连接
export function createWebSocket(fn){
  try{
    if ('WebSocket' in window) {
      websocket = new WebSocket(`${url}/webSocketServer?token=${getToken()}`);
    } else if ('MozWebSocket' in window) {
      websocket = new MozWebSocket(`${url}/webSocketServer?token=${getToken()}`);
    } else {
      websocket = new SockJS(`${url}/sockjs/webSocketServer?token=${getToken()}`);
    }
  }catch {
    reconnect();
    return;
  }
 
  websocket.onopen = function(event) {
   // websocket.send("连接成功");
    console.log("服务已连接")
  };
 
  websocket.onmessage = function(event){
    var data=JSON.parse(event.data);
    if(data.type === 'exit'){
      MessageBox.alert(data.name, '提示', {
        dangerouslyUseHTMLString: true,
        showConfirmButton: true,
        type: 'warning',
      }).then(()=>{
        store.dispatch('user/resetToken').then(() => {
          removeToken();
          // window.location.reload();
          router.replace("/login")
        });
      });
 
    }
    fn(data);
 
 
  };
  websocket.onclose = function(event) {
    console.log("服务连接关闭")
  };
  websocket.onerror = function(event) {
 
    console.log(event,"连接出错")
  };
}
/**
 *  异常处理
 * 处理可以检测到的异常，并尝试重新连接
 */
function reconnect() {
  if (lockReconnect) {
    return;
  }
  console.log("reconnect");
  lockReconnect = true;
  // 没链接上会一直连接，设置延迟，避免过多请求
  wsCreateHandler && clearTimeout(wsCreateHandler);
  wsCreateHandler = setTimeout(function() {
    console.log("-----websoket异常-------");
    createWebSocket();
    lockReconnect = false;
  }, 1000);
}
export function websocketClose() {
  console.log('执行了关闭')
  websocket.close();    //手动关闭websocket
}
```



#### Ajax









------



#### 浅拷贝和深拷贝

解释见：数据结构中堆和栈

常见5种深拷贝实现方法

```javascript
//	深拷贝常用方法
//	1，ES6解构赋值【注意: 这种方式只能用于单层json对象，也就是对象中的每个value都是基本类型，没有嵌套。】
let a = {key1: 1}
let b = {...a}
b.key1 = 2
console.log(a) // {key1: 1}

//	2，ES6中Object.assign【注意: 这种方式只能用于单层json对象，也就是对象中的每个value都是基本类型，没有嵌套】
var a = { key1: 1 };
var b = Object.assign({}, a);

//	3，JSON方法【这个是可以对多层json对象进行拷贝的】
const clone = JSON.parse(JSON.stringify(original));

//	4，自定义递归函数
function deepClone(o1, o2) {
    for (let k in o2) {
        if (typeof o2[k] === 'object') {
            o1[k] = {};
            deepClone(o1[k], o2[k]);
        } else {
            o1[k] = o2[k];
        }
    }
}

//	5，第三方JS库【如Lodash、Jquery】
lodash.clonedeep
$.extend([deep ], target, object1 [, objectN ])
```

------



#### 闭包

1. **什么是闭包？**

「函数」和「函数内部能访问到的变量」的总和，或者说是同一个作用域内的函数和变量总何，就是一个闭包

2. **为什么需要闭包？**

局部变量无法共享和长久保存，而全局变量可能造成变量污染，所以我们希望有一种机制既可以长久保存变量又不会造成全局污染。

3. **特点**

- [ ] 占用更多内存
- [ ] 不容易被释放

4. **何时使用？**

变量既想反复使用，又想避免全局污染，就可以使用闭包

5. **如何使用？**

- [ ] 定义外层函数，封装被保护的局部变量。

- [ ] 定义内层函数，执行对外部函数变量的操作。

- [ ] 外层函数返回内层函数的对象，并且外层函数被调用，结果保存在一个全局的变量中。

------



#### 递归

1. 什么是递归：

   如果一个函数在内部可以调用其本身，那么这个函数就是递归函数。

   简单理解:函数内部自己调用自己, 这个函数就是递归函数

2. 递归必须由以下两部分组成

   - 递归调用的过程
   - 递归终止的条件

3. 普通递归都是很消耗资源

------



#### 防抖

函数防抖（debounce）：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。持续触发click事件时，并不执行handle函数，当1000毫秒内没有触发click事件时，才会延时触发click事件。



#### 节流

函数节流（throttle）：指定时间间隔内只会执行一次任务。

规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。持续触发click事件时，并不立即执行handle函数，每隔1000毫秒才会执行一次handle函数。



二者区别
函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。

```
let _debounceTimeout = null,
	_throttleRunning = false

/**
 * 防抖
 * @param {Function} 执行函数
 * @param {Number} delay 延时ms
 */
export const debounce = (fn, delay=500) => {
	clearTimeout(_debounceTimeout);
	_debounceTimeout = setTimeout(() => {
		fn();
	}, delay);
}
/**
 * 节流
 * @param {Function} 执行函数
 * @param {Number} delay 延时ms
 */
export const throttle = (fn, delay=500) => {
	if(_throttleRunning){
		return;
	}
	_throttleRunning = true;
	fn();
	setTimeout(() => {
	    _throttleRunning = false;
	}, delay);
}
```



### ES6基础知识

#### 箭头函数



#### Promise

1. Promise是一个构造函数

![image-20221222082001507](/Users/jiangchuan/Library/Application Support/typora-user-images/image-20221222082001507.png)

2. Promise的状态

​	实例对象中的一个属性 【PromiseState】

- pending	未决定
- Resolved / fullfilled  成功
- Rejected  失败

3.	Promise对象的值 

实例对象中的另一个属性 【PromiseResult】

保存着异步任务【成功/失败】的结果

4. Promise的工作流程

![image-20221222081917748](/Users/jiangchuan/Library/Application Support/typora-user-images/image-20221222081917748.png)



------





### TypeScript

​	type: `type`关键字是声明类型别名的关键字。它的语法如下：

```javascript
type AliasName = Type;
// type：声明类型别名的关键字
// AliasName：类型别名的名称
// Type：类型别名关联的具体类型
```

​	interface:通过关键字 `interface`可以定义一个[接口类型](https://so.csdn.net/so/search?q=接口类型&spm=1001.2101.3001.7020)。它能合并众多类型声明至一个类型声明。

接口声明只存在于编译阶段，在编译后生成的 JS 代码中不包含任何接口代码。

语法如下：

```javascript
interface InterfaceName {
  TypeMember;
  TypeMember;
  ...
}
// interface：定义接口的关键字
// InterfaceName：接口名，首字母需要大写
// TypeMember：接口的类型成员
```

相同点

- 都可以用来定义 **对象** 或者 **函数** 的结构，而严谨的来说，type 是引用，而 `interface`是定义

不同点

- type 在声明类型别名之后**实际上是一个赋值操作，它需要将别名与类型关联起来**。也就是说类型别名不会创建出一种新的类型，它只是给已有类型命名并直接进行引用。`interface`是**定义了一个接口类型。**
- type 能够**表示非对象类型，** 而 `interface` 则**只能表示对象类型**。
- `interface`可以**继承其他的接口、类等对象类型，** type 不支持继承。
- `interface`接口名总是会直接显示在编译器的诊断信息和代码编辑器的智能提示中，而 **type 的名字只在特定情况**下才会显示出来——只有当类型别名表示**数组类型、元组类型以及类或者接口的泛型实例类型**时才展示。
- `interface`具有声明合并的行为，而 `type`不会，这也意味着我们可以通过声明合并的方式给 `interface`定义的类型进行属性扩展。
- `type`可以通过 `typeof`来获取实例的类型从而进行赋值操作

------



## 前端进阶

### 软件架构设计模式

1. MVC（模型—视图—控制器）

   它通过关注点分离鼓励改进应用程序组织。它强调将业务数据(Model)与用户界面(View)隔离

   Controller可以直接访问Model，也可以直接控制View,但是Model和View不能相互通信，相当于COntroller就是介于这两者之间的协调者。

   

2. MVVM (M模型—V控制器—VM视图模型)

   ViewModel(视图模型):就是View和Model层的粘合剂，封装业务逻辑处理，封装网络处理，封装数据缓存。就是把原来ViewController层的业务逻辑和页面逻辑等剥离出来放到ViewModel层

   vue2中的双向绑定数据就是典型的MVVM模式

   

3. 微前端

   

   ------

   



### vue2.js

#### vue2实现原理

Vue2 是采用数据劫持结合发布者-订阅者模式的方式来实现数据的响应式，通过 Object.defineProperty() 方法进行的数据劫持，通过递归的方式对所有属性都添加 setter、getter 方法进行监听，在数据变动时发布消息给订阅者，订阅者收到消息后进行相应的处理。

当访问或设置对象的属性的时候，都会触发相对应的函数，然后在这个函数里返回或设置属性的值，我们可以在触发函数的时候做点我们自己想做的事情，这也就是“劫持”操作。

> vue发布与订阅

1. observer，创建数据监听，并为每个属性建立一个发布类。

2. Dep是发布订阅者模型中的发布者：get数据的时候，收集订阅者，触发Watcher的依赖收集；set数据时发布更新，通知Watcher 。一个Dep实例对应一个对象属性或一个被观察的对象，用来收集订阅者和在数据改变时，发布更新。

3. Watcher是发布订阅者模型中的订阅者：订阅的数据改变时执行相应的回调函数（更新视图或表达式的值）。一个Watcher可以更新视图，如html模板中用到的{{test}}，也可以执行一个$watch监督的表达式的回调函数（Vue实例中的watch项底层是调用的$watch实现的）,还可以更新一个计算属性（即Vue实例中的computed项）

新增或删除对象属性，界面不会更新。【`this.$set`、 `Vue.set` 和 `splice`（仅数组适用）】

直接通过下标修改数组，界面不会更新

```javascript
//	如果是object，则通过Object.defineProperty(obj,key,descriptor)拦截对象属性访问
function defineReactive(obj, key, val) {
  Object.defineProperty(obj, key, {
    get() {
      return val
    },
    set(v) {
      val = v
      notify()
    }
  })
}
//	如果是数组，则覆盖数组的7个变更方法实现变更通知
const arrayProto = Array.prototype
const arrayMethods = Object.create(arrayProto)

;['push','pop','shift','unshift','splice','sort','reverse']
  .forEach(function (method) {
  const original = arrayProto[method]
  def(arrayMethods, method, function mutator (...args) {
    const result = original.apply(this, args)
    notify()
    return result
  })
})
/* 问题：
1,初始化时需要遍历对象所有key，如果对象层级较深，性能不好
2,通知更新过程需要维护大量dep实例和watcher实例，额外占用内存较多
3,动态新增、删除对象属性无法拦截，只能用特定set/delete api代替
4,不支持新的Map、Set等数据结构
*/
```

优点：

- 降低耦合：视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的"View"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。
- 可重用性：可以把一些视图逻辑放在ViewModel层中，让很多View重用这些视图逻辑。
- 独立开发：开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。
- 可测试：界面素来是比较难于测试的，测试可以针对ViewModel来写。

缺点：

- 深度监听，需要递归到底，一次性计算量大，资源消耗大
- 无法监听新增、删除属性（需要vue.set 和 vue.delete）
- 无法原生监听数组，需要特殊处理

------

#### deff算法

1. diff算法是干什么的

   diff算法是一种通过同层的树节点进行比较的高效算法

   它有2个特点：1，比较只会在同层级中，不会跨层级。2，在diff比较的过程中，循环从两边向中间比较

2. vue中的diff算法

   Vue中的diff算法称为patching算法，它由Snabbdom修改而来，虚拟DOM要想转化为真实DOM就需要通过patch方法转换，是对新旧两条虚拟DOM进行逐层比较并更新真实DOM。

   当页面上的数据发生变化时，Vue 不会立即渲染。而是经过 diff 算法，判断出哪些是不需要变化的，哪些是需要变化更新的，只需要更新那些需要更新的 DOM 就可以了，这样就减少了很多不必要的 DOM 操作，大大提升了性能。

   最初Vue1.x视图中每个依赖均有更新函数对应，可以做到精准更新，因此并不需要虚拟DOM和patching算法支持，但是这样粒度过细导致Vue1.x无法承载较大应用；Vue 2.x中为了降低Watcher粒度，每个组件只有一个Watcher与之对应，此时就需要引入patching算法才能精确找到发生变化的地方并高效更新。

3. 它何时执行及具体执行方式

   vue中diff执行的时刻是组件内响应式数据变更触发实例执行其更新函数时，更新函数会再次执行render函数获得最新的虚拟DOM，然后执行patch函数，并传入新旧两次虚拟DOM，通过比对两者找到变化的地方，最后将其转化为对应的DOM操作。

   patch过程是一个递归过程，遵循深度优先、同层比较的策略；以vue3的patch为例：

   - 首先判断两个节点是否为相同同类节点，不同则删除重新创建
   - 如果双方都是文本则更新文本内容
   - 如果双方都是元素节点则递归更新子元素，同时更新元素属性
   - 更新子节点时又分了几种情况：
     - 新的子节点是文本，老的子节点是数组则清空，并设置文本；
     - 新的子节点是文本，老的子节点是文本则直接更新文本；
     - 新的子节点是数组，老的子节点是文本则清空文本，并创建新子节点数组中的子元素；
     - 新的子节点是数组，老的子节点也是数组，那么比较两组子节点，更新细节

    

4. 关键词

   sameVnode，patchVnode，updateChildren



#### vue生命周期

1. vue2->vue3生命周期对应关系

   ```javascript
   beforeCreate -> setup	//创建前
   created -> setup	//创建后
   beforeMount -> onBeforeMount	//加载前
   mounted -> onMounted	//加载后
   beforeUpdate -> onBeforeUpdate	//更新前
   updated -> onUpdated	//更新后
   beforeDestroy -> onBeforeUnmount	//销毁前
   destroyed -> onUnmounted	//销毁后
   ```

   

2. 父子组件挂载顺序

   ```javascript
   父beforeCreate -> 父created -> 父beforeMount -> 
   子beforeCreate -> 子created -> 子beforeMount -> 子mounted -> 
   父mounted
   ```

   

3. 父子组件更新顺序

   ```javascript
   父beforeUpdate -> 子beforeUpdate -> 子updated -> 父updated
   ```

   

4. 父子组件销毁顺序

   ```javascript
   父beforeDestroy -> 子beforeDestroy -> 子destroyed -> 父destroyed
   ```






#### computed计算属性

**什么是计算属性**

模板内的表达式非常便利，但是设计它们的初衷是用于**简单运算的**。在模板中放入太多的逻辑会让模板过重且难以维护。

**原理**

底层借助了Object.[defineproperty](https://so.csdn.net/so/search?q=defineproperty&spm=1001.2101.3001.7020)方法提供的getter和setter

优势

与methods实现相比，内部有缓存机制（复用），效率更高，调用方便

与watch相比，无法实现异步请求





#### 组件通信

1. props、emit【单向数据流】

2. $parent、$children【难以定位】

2. Ref、$refs【非响应式】

2. $attrs、$listeners【多级嵌套】

2. $emit、$on【事件总线】

3. provide和inject【依赖、注入】

   ```javascript
   // vue2实现
   
   // 根组件
   ...
   data() {
    return {
     msg: ‘I am origin component data’
    }
   },
   provide: function() {
    return {
     getData() {
      console.log(‘hi，I come from origin component’)
     }
    },
    msg: this.msg
   },
   ...
   
   //子组件
   ...
   inject: [‘getData’, ‘msg’],
   created() {
    this.init()
   },
   methods: {
    init() {
     console.log(this.msg),
     this.getData()
    }
   }
   ...
   
   ```



```javascript
// vue3实现

// 根组件
import { ref, provide, readonly } from 'vue'
const name = ref('admin')	// 提供动态数据
provide('name', readonly(name)) // readonly函数提供数据只读功能，保持单向数据流，防止子组件改变根组件中的数据

//子组件
import { ref, inject } from 'vue'
const name = inject('name', 'user') // 第二个参数是如果取值时没有取到而给的一个默认值，防止程序报错

...
<input v-model="name" type="text" />
```

注意：如果中间组件有同名provide，子组件inject取值会遵循就近原则，也就是中间组件的同名provide值会覆盖根组件的值



#### keep-alive(路由缓存)

在平常开发中，有部分组件没有必要多次初始化，这时，我们需要将组件进行持久化，**使组件的状态维持不变**，在下一次展示时，也不会进行重新初始化组件。

也就是说，`kee-alive` 是 `Vue` 内置的一个组件，可以**使被包含的组件保留状态，或避免重新渲染** 。也就是所谓的**组件缓存**

##### 基本用法

```xml
//被keep-alive包含的组件会被缓存
<keep-alive>
    <component />
</keep-alive>
复制代码
```

被`keep-alive`包含的组件不会被再次初始化，也就意味着**不会重走生命周期函数**
 但是有时候是希望我们缓存的组件可以能够再次进行渲染，这时`Vue`为我们解决了这个问题
 被包含在 `keep-alive` 中创建的组件，会多出两个生命周期的钩子: `activated` 与 `deactivated`：

- `activated` 当 `keep-alive` 包含的组件再次渲染的时候触发
- `deactivated` 当 `keep-alive` 包含的组件销毁的时候触发

**`keep-alive`是一个抽象的组件，缓存的组件不会被`mounted`,为此提供`activated`和`deactivated`钩子函数**

**在2.1.0 版本后`keep-alive`新加入了两个属性: `include`(包含的组件缓存生效) 与 `exclude`(排除的组件不缓存，优先级大于`include`) 。**

在VUE3中，当组件在 `<keep-alive>` 内被切换时，它的 `mounted` 和 `unmounted` 生命周期钩子不会被调用，取而代之的是`activated`和`deactivated`.

###### 参数理解

`keep-alive`可以接收3个属性做为参数进行匹配对应的组件进行缓存:

- `include`包含的组件(可以为字符串，数组，以及正则表达式,只有匹配的组件会被缓存)
- `exclude`排除的组件(以为字符串，数组，以及正则表达式,任何匹配的组件都不会被缓存)
- `max`缓存组件的最大值(类型为字符或者数字,可以控制缓存组件的个数)

**注：当使用正则表达式或者数组时，一定要使用`v-bind`**

**代码示例：**

```javascript
// 只缓存组件name为a或者b的组件
<keep-alive include="a,b"> 
  <component />
</keep-alive>

// 组件name为c的组件不缓存(可以保留它的状态或避免重新渲染)
<keep-alive exclude="c"> 
  <component />
</keep-alive>

// 如果同时使用include,exclude,那么exclude优先于include， 下面的例子只缓存a组件
<keep-alive include="a,b" exclude="b"> 
  <component />
</keep-alive>

// 如果缓存的组件超过了max设定的值5，那么将删除第一个缓存的组件
<keep-alive exclude="c" max="5"> 
  <component />
</keep-alive>
复制代码
```

###### 配合`router`使用

`router-view`也是一个组件，如果直接被包在`keepalive`里面，那么所有路径匹配到的视图组件都会被缓存，如下：

```xml
<keep-alive>
    <router-view>
        <!-- 所有路径匹配到的视图组件都会被缓存！ -->
    </router-view>
</keep-alive>
复制代码
```

**如果只想要`router-view`里面的某个组件被缓存，怎么办？**

- 使用 `include/exclude`
- 使用 `meta` 属性

1.使用 `include` (`exclude`例子类似)

```xml
//只有路径匹配到的 name 为 a 组件会被缓存
<keep-alive include="a">
    <router-view></router-view>
</keep-alive>
复制代码
```

2.使用 `meta` 属性

```yaml
// routes 配置
export default [
  {
    path: '/',
    name: 'home',
    component: Home,
    meta: {
      keepAlive: true // 需要被缓存
    }
  }, {
    path: '/profile',
    name: 'profile',
    component: Profile,
    meta: {
      keepAlive: false // 不需要被缓存
    }
  }
]
复制代码
<keep-alive>
    <router-view v-if="$route.meta.keepAlive">
        <!-- 这里是会被缓存的视图组件，比如 Home！ -->
    </router-view>
</keep-alive>

<router-view v-if="!$route.meta.keepAlive">
    <!-- 这里是不会被缓存的视图组件，比如 Profile！ -->
</router-view>
复制代码
```

###### 防坑指南

1.`keep-alive` 先匹配被包含组件的 `name` 字段，如果 `name` 不可用，则匹配当前组件 `components` 配置中的注册名称。
 2.`keep-alive` 不会在函数式组件中正常工作，因为它们没有缓存实例。
 3.当匹配条件同时在 `include` 与 `exclude` 存在时，以 `exclude` 优先级最高(当前vue 2.4.2 version)。比如：包含于排除同时匹配到了组件A，那组件A不会被缓存。
 4.包含在 `keep-alive` 中，但符合 `exclude` ，不会调用`activated`和 `deactivated`。



##### **vue3中的用法**

`<keep-alive>` 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。`<keep-alive>` 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。当组件在 `<keep-alive>` 内被切换时，它的 `mounted` 和 `unmounted` 生命周期钩子不会被调用，取而代之的是`activated`和`deactivated`.

###### 使用

- ##### 在路由组件配置文件当中配置组件是否需要被缓存，配置`meta`属性

```js
{ 
  path: '/dynamic', 
  name: 'Dynamic', 
  component: () => import('@/views/Dynamic.vue'), 
  meta: { 
    keepAlive: true, 
    showFooter: true, 
   } 
},
复制代码
```

- ##### 在根组件`App.vue`中使用`keep-alive`标签包含需要缓存的组件

```js
<!-- 这是vue3的写法，与vue2的写法有所区别，如果这里使用vue2.x写法，会有警告 -->
<router-view v-slot="{ Component }">
  <keep-alive>
    <component :is="Component" :key="$route.name" v-if="$route.meta.keepAlive" />
  </keep-alive>
  <component :is="Component" :key="$route.name" v-if="!$route.meta.keepAlive" />
</router-view>
复制代码
```

- ##### 缓存页面使用

```js
onActivated(() => { // 被包裹组件被激活的状态下触发
      // 逻辑代码
 }
onDeactivated(() => { // 在被包裹组件停止使用时触发
    // 逻辑代码
})
复制代码
```

###### 注意

- `页面第一次进入的时候，钩子触发的顺序是created->mounted->activated，所以别在mounted和activated方法中写相同的逻辑代码`
- `多页面缓存需要配置key属性，来表示组件的唯一性和对应关系，如：:key="$route.path"`
- `不要动态修改meta.keepAlive的值控制是否缓存，因为第一次是创建组件，没有缓存，需要缓存后，下一次进入才不会触发逻辑代码，如果最开始进入的时候meta.keepAlive值为false的话，渲染的是没有使用keep-alive的组件，则会触发相应代码`





#### vue常见修饰符

什么是修饰符？**修饰符 (Modifiers)：** 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。

1. 事件修饰符【用法：@click.stop="submit"】

   - .stop - 阻止单击事件继续传播, 也就是阻止冒泡

   - .prevent - 提交事件不再重新加载页面, 可以用来阻止表单提交的默认行为

     注意点: .stop和.prevent可以串联在一起使用,都会生效

   - .capture - 内部元素触发的事件先在此处理，然后才交由内部元素进行处理

   - .self - 只当在 event.target 是当前元素自身时触发处理函数,即事件不是从内部元素触发的
     注意点: 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 

   - v-on:click.self.prevent 只会阻止对元素自身的点击。

   .once - 点击事件将只会触发一次, 不只能对原生DOM时间生效,还可以用在自定义组件上
   .passive - 立即触发默认行为,能够提升移动端性能,和.prevent一起使用时.prevent会被忽略并警告
   .native - 使用时将被当做原生的HTML标签看待,绑定事件可以生效

2. 按键修饰符【用法：@keyup.keyCode="shout()"】

   - .keyup - 键盘抬起
   - .keydow - 键盘按下
   - 按键码 - 在按键修饰符后面添加,用于监听键盘按下哪个键【如：.enter、.up、.down】

3. 系统修饰键【用法：@click.ctrl="submit"】

   - **`.ctrl`**	按住ctrl后点击才有效果
   - **`.alt`**
   - **`.shift`**
   - **`.meta`**

4. 鼠标按键修饰符【用法：@click.left="submit"】

   - .left - 只有鼠标左键点击触发`
   - `.right - 只有鼠标右键点击触发`
   - .middle - 只有鼠标中键点击触发`

5. 表单修饰符【用法：v-model.number】

   - .lazy - 在表单输入时不会马上显示在页面,而是等输入完成失去焦点时才会显示在页面
   - .trim - 过滤表单输入时前后的空格
   - .number - 限制输入数字或将输入的数据转为数字

------





#### mixins混入使用

1. 什么是Mixins？

   mixins（混入），官方的描述是一种分发 Vue 组件中可复用功能的非常灵活的方式，mixins是一个js对象，它可以包含我们组件中script项中的任意功能选项，如data、components、methods 、created、computed等等。我们只要将共用的功能以对象的方式传入 mixins选项中，当组件使用 mixins对象时所有mixins对象的选项都将被混入该组件本身的选项中来，这样就可以提高代码的重用性，使你的代码保持干净和易于维护。

2. 什么时候使用Mixins？

   当我们存在多个组件中的数据或者功能很相近时，我们就可以利用mixins将公共部分提取出来，通过 mixins封装的函数，组件调用他们是不会改变函数作用域外部的。

3. 如何创建Mixins？

   在src目录下创建一个mixins文件夹，文件夹下新建一个myMixins.js文件。前面我们说了mixins是一个js对象，所以应该以对象的形式来定义myMixins，在对象中我们可以和vue组件一样来定义我们的data、components、methods 、created、computed等属性，并通过export导出该对象

   <img src="https://img-blog.csdnimg.cn/20200805173501551.png" alt="img" style="zoom:67%;" />

4. 如何使用Mixins？

   在需要调用的组件中引入myMixins.js文件，然后在export default 中引入你需要的对象即可

   <img src="https://img-blog.csdnimg.cn/20200805173523981.png" alt="img" style="zoom:80%;" />

5. 与vuex的区别

   **vuex：**用来做状态管理的，里面定义的变量在每个组件中均可以使用和修改，在任一组件中修改此变量的值之后，其他组件中此变量的值也会随之修改。

   **Mixins：**可以定义共用的变量，在每个组件中使用，引入组件中之后，各个变量是相互独立的，值的修改在组件中不会相互影响。

6. 与公共组件的区别

   **组件**：在父组件中引入组件，相当于在父组件中给出一片独立的空间供子组件使用，然后根据props来传值，但本质上两者是相对独立的。

   **Mixins：**则是在引入组件之后与组件中的对象和方法进行合并，相当于扩展了父组件的对象与方法，可以理解为形成了一个新的组件。

------



#### nextTick

1. nextTick是Vue提供的一个全局API，由于vue的异步更新策略导致我们对数据的修改不会立刻体现在dom变化上，此时如果想要立即获取更新后的dom状态，就需要使用这个方法
2. Vue 在更新 DOM 时是**异步**执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。nextTick方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用。
3. 所以当我们想在修改数据后立即看到dom执行结果就需要用到nextTick方法。比如，我在干什么的时候就会使用nextTick，传一个回调函数进去，在里面执行dom操作即可。
4. 它会在callbacks里面加入我们传入的函数，然后用timerFunc异步方式调用它们，首选的异步方式会是Promise。这让我明白了为什么可以在nextTick中看到dom操作结果。

```javascript
// vue2
<a-boo v-if="otherParam.showA"></a-boo>
this.abc = false
this.$nextTick(() => {
   //你要执行的方法
     this.abc = true
})


// vue3
import { nextTick } from 'vue'
setup() {
    const message = ref('Hello!')
    // 异步中使用
    const changeMessage = async newMessage => {	
      message.value = newMessage
      await nextTick()
    }
    // 普通用法
    let otherParam = reactive({
        showA:false
    })
    nextTick(()=>{
        otherParam.showA = true
    })
  }

```



------



#### 扩展Vue组件

常见的组件扩展方法有：mixins，slots，extends等

混入的数据和方法不能明确判断来源且可能和当前组件内变量产生命名冲突，vue3中引入的composition api，可以很好解决这些问题

------



#### 提升vue性能

- 路由懒加载减少应用尺寸，图片懒加载，组件懒加载
- 利用SSR减少首屏加载时间【服务端渲染】
- 利用v-once渲染那些不需要更新的内容，按条件跳过更新时使用`v-momo`
- 一些长列表可以利用虚拟滚动技术避免内存过度占用
- 对于深层嵌套对象的大数组可以使用shallowRef或shallowReactive降低开销
- 避免不必要的组件抽象
- `keep-alive`缓存页面
- 事件的销毁：Vue 组件销毁时，会自动解绑它的全部指令及事件监听器，但是仅限于组件本身的事件
- 第三方插件按需引入。

------





### vue3.js

#### vue3实现原理

​	Vue3 是实现原理是用 ES6 中的 Proxy 方法来实现的

```javascript
/* target: 目标对象，待要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。 */
/* handler: 一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 proxy 的行为。 */ 
const proxy = new Proxy(target, handler);
```

​	Proxy 对象用于创建一个对象的代理，通过handler对象的拦截方法从而实现目标对象target的基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。可以理解为，在目标对象之前有一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。

​	Proxy 并不能监听到对象内部深层次的属性变化，因此它的处理方式是在 get 中去递归响应性，这样做的好处是真正访问到的内部属性才会变成响应性，简单的可以说是按需实现响应性，减少性能消耗

```javascript
function defineReactive(obj) {
  return new Proxy(obj, {
    get(target, key) {
      track(target, key)
      return Reflect.get(target, key)
    },
    set(target, key, val) {
      Reflect.set(target, key, val)
      trigger(target, key)
    },
    deleteProperty(target, key) {
      Reflect.deleteProperty(target, key)
      trigger(target, key)
    }
  })
}
//	可以同时支持object和array，动态属性增、删都可以拦截，新增数据结构均支持，对象嵌套属性运行时递归，用到才代理，也不需要维护特别多的依赖关系
```

​	

> target的拦截操作

​	get 拦截对象属性的读取

​	set 拦截对象属性的设置

​	has 拦截 key in proxy 的操作

​	deleteProperty

​	...

Proxy 支持 13 种拦截操作，除了上面的的几种常见的操作，还支持其它多种行为的拦截

| 实现原理 | defineProperty           | Proxy                   | value setter      |
| -------- | ------------------------ | ----------------------- | ----------------- |
| 实际场景 | Vue2 响应式              | Vue3 reactive           | Vue3 ref          |
| 优势     | 兼容性                   | 基于Proxy实现真正的拦截 | 实现简单          |
| 劣势     | 数组和属性删除等拦截不了 | 不兼容IE11              | 只拦截了value属性 |
| 实际应用 | Vue2                     | Vue3 复杂数据结构       | Vue3 简单数据结构 |





vue3中用计算属性代替过滤器（filter）

#### ref与reactive

1. 定义数据角度：

   ref：定义一个响应式的基本类型数据

   reactive：定义一个响应式的对象类型数据

   注意：ref也可以用于定义对象（数组）类型数据，在内部会自动通过reactive转化为代理对象

2. 响应式原理角度

   ref：响应式依然依靠Object.defineProperty()中的set()方法与get()方法实现

   reactive：响应式依靠Proxy代理源对象与Reflect反射操作源对象实现

3. 使用角度

   ref：操作数据需要加.value，在html模板中不需要加.value

   reactive：操作数据均不需要加.value

#### watchEffect与watch

1. 在options api(vue2)中我们采用watch来监听data中的数据或者props中的参数变化。在componsiton api(vue3)中我们采用watchEffect和watch来进行监听数据变化，并且watchEffect是自动收集依赖，watch则需要我们自己指定需要监听的数据。

2. watchEffect

   立即执行传入的一个函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。

   特性

   - `watchEffect`不需要指定监听的属性，他会自动的收集依赖， 只要我们回调中引用到了 响应式的属性， 那么当这些属性变更的时候，这个回调都会执行。
   - `watchEffect`必须立即执行一次(依赖收集)；注意: 依赖太多各种坑。
   - 可停止监听。

3. watch

   componsition api中的watch和options api中的watch一样，都是用来监听某一个属性发生变化，执行相关的回调。
   watchEffect和watch进行对比，watch是懒执行的(也就是说第一次不执行)。执行时会将newValue和oldValue传入函数。

   特性

   - 惰性地执行；

   - 更具体地说明应触发侦听器重新运行的状态；

   - 访问被侦听状态的先前值和当前值。

   - 可监听单个或多个源数据。

   - 默认不会立即执行。添加 `{ immediate:true }` 可以立即执行，没有惰性。

   - 不可以停止监听。

   - 添加第三个参数 `{deep: true}` 深度监听。

     

4. watchEffect 与 watch 有什么不同
   第一点我们可以从示例代码中看到 watchEffect 不需要指定监听的属性，他会自动的收集依赖， 只要我们回调中引用到了 响应式的属性， 那么当这些属性变更的时候，这个回调都会执行，而 watch 只能监听指定的属性而做出变更(v3开始可以同时指定多个)。
   第二点就是 watch 可以获取到新值与旧值（更新前的值），而 watchEffect 是拿不到的。
   第三点是 watchEffect 如果存在的话，在组件初始化的时候就会执行一次用以收集依赖（与computed同理），而后收集到的依赖发生变化，这个回调才会再次执行，而 watch 不需要，因为他一开始就指定了依赖。

5. watch与computed的区别

   computed可以更简洁地实现功能，watch则可以实现 一些特殊的功能，比如异步请求

   computed还具有缓存功能

6. 示例

   ```javascript
   import { ref, watch } from 'vue'
   export default {
   	setup() {
   	    // 直接侦听一个
   		const count = ref(0)
   		watch(count, (count, prevCount) => {
   		  /* ... */
   		}
   
   		// 直接侦听多个
   		const fooRef = ref(0);
   		const barRef = ref(0);
   		watch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) => {
   		  /* ... */
   		},{deep: true})
   	    return { count, fooRef, barRef }
   	}
   }
   
   
   
   //watchEffect
   import { ref, watchEffect } from 'vue'
   export default {
   	setup() {
   	    const count = ref(0)
   	    setInterval(() => {
         		count.value++
       	}, 1000)
       	 /** 这个hook用以监听count.value的变化 */
           watchEffect(() => console.log(count.value))
   	    // -> logs 0
   	    // -> logs 1
   	    // -> logs 2
   	    // -> logs 3
   	    // -> logs 4
   	    // -> logs ...
   	    return { count }
   	}
   }
   
   ```

   

##### 



#### getCurrentInstance



#### hooks

一、 什么是hooks

hook是钩子的意思，看到“钩子”是不是就想到了钩子函数？事实上，hooks 还真是函数的一种写法。

vue3 借鉴 react hooks 开发出了 Composition API ，所以也就意味着 Composition API 也能进行自定义封装 hooks。

vue3 中的 hooks 就是函数的一种写法，就是将文件的一些单独功能的js代码进行抽离出来，放到单独的js文件中，或者说是一些可以复用的公共方法/功能。其实 hooks 和 vue2 中的 mixin 有点类似，但是相对 mixins 而言， hooks 更清楚复用功能代码的来源, 更清晰易懂。

二、hooks的用法

1. 在src中创建一个hooks文件夹，用来存放hook文件

2. 根据需要写hook文件，比如要实现一个功能就是在 点击页面时，记录鼠标当前的位置，可以在hooks文件夹中新建一个文件useMousePosition.ts，

3. hook文件的使用：在需要用到该`hook`功能的组件中的使用，比如在 test.vue文件中

   

#### toRef和toRefs

**作用：toRef、toRefs用于将reactive内的节点提取出来，同时具有响应式结构。**

toRef 和 toRefs 可以用来复制 reactive 里面的属性然后转成 ref，而且它既保留了响应式，也保留了引用，也就是你从 reactive 复制过来的属性进行修改后，除了视图会更新，原有 ractive 里面对应的值也会跟着更新，如果你知道 浅拷贝 的话那么这个引用就很好理解了，它复制的其实就是引用 + 响应式 ref
不加 s 和 加 s 的区别就是这样：

toRef: 复制 reactive 里的单个属性并转成 ref
toRefs: 复制 reactive 里的所有属性并转成 ref

注意：

**toRef与toRefs都是将reactive的json内节点提取出来，做为独立的响应式结构。**

**二者的区别在于：toRef是指定某一节点提取出来，toRefs是一次性将所有节点提取出来。但toRefs只能提取一级节点！**

**toRefs返回的变量修改，与原始值无任何响应式关联。**

- template 要想访问 toRefs 的值，需要带上 `.value` 如果不带上，就会出现双引号。
- template 要想访问 toRef 的值，不需要带上 `.value`





#### shallowReactive和shallowRef

一，介绍
1.相对于ref和reactive，shallowRef 和shallowReactive创建的数据是浅响应式的

二，shallowRef介绍
1.shallowRef可以创建一个跟踪自身 .value 变化的 ref，但不会使其值也变成响应式的

2.当使用shallowRef为一个基础类型数据创建响应性时，行为是和ref一样的。

3.不同的是，当使用shallowRef为复杂类型创建响应性时，修改深层属性，不具备响应性

```javascript
const a = shallowRef({b:1})
a.value.b = 2  //视图不会更新
console.log(a.value) //{b : 2} 但是能追踪到值得变化

a.value={b:2} //一整个替换时，视图会变化
```

三，shallowReactive介绍
1.创建一个响应式代理，它跟踪其自身 property 的响应性，但不执行嵌套对象的深层响应式转换 (暴露原始值)

2.相对于reactive，shallowReactive只有最外层的属性是响应的

```javascript
const state = shallowReactive({
  foo: 1,
  nested: {
    bar: 2
  }
})

// 改变 state 本身的性质是响应式的
state.foo++
// ...但是不转换嵌套对象
isReactive(state.nested) // false
state.nested.bar++ // 非响应式
```

四，对数据进行非深度监听

我们发现无论写多少层数据；
数据层级有多深，ref始终会对数据进行深度监听。
这显然不是我们需要的。
我们迫切需要对数据进行非深度监听。
这个时候，我们就需要shallowReactive和shallowRef

对数据进行非深度监听，往往**可以提升数据的性能**





#### toRaw和markRaw

1. toRaw()函数


接收一个reactive响应式数据,将一个响应式的数据变为普通类型的数据,转化为非响应式数据,相当于还原对象,reactive相当于制作,但对于ref响应式数据不起作用

将一个由reactive生成的响应式对象转为普通(原始)对象

toRaw()可以返回由reactive(),readonly(),shallowReactive()或shallowReadonly()创建的代理对应的原始对象

这是一个可以用临时读取而不引起代理访问/跟踪开销,或是写入而不触发更改的特殊方法,在官方文档里,是不建议保存对原始对象的持久引用

使用场景:用于读取响应式对象的普通对象,对这个普通对象的所有操作,不会引起页面的更新

const foo = {}
const reactiveFoo = reactive(foo)
console.log(toRaw(reactiveFoo) === foo)  // true
注意

针对对象,后续动态新增的属性,如果没有把整个对象对外暴露出去,模板中使用新增的变量是不生效的(针对setup函数形式)



2. markRaw()函数

接收一个原始数据,标记一个对象,使它永远不会再成为响应式对象,也就是数据在逻辑中即使修改变化了,但是页面不会更新变化

将一个对象标记为不可被转为代理,返回该对象本身

应用场景:

[1]. 有些值不应该被设置为响应式的,例如复杂的第三方类库或Vue组件对象

[2]. 当渲染具有不可变数据源的大列表时,跳过响应式转换可以提高性能

const foo = markRaw({})
console.log(isReactive(reactive(foo))) // false
// 也适用于嵌套在其他响应性对象
const bar = reactive({ foo })
console.log(isReactive(bar.foo)) // false
markRaw()与shallowReactive()这样浅层式API使你可以有选择的避开默认的深度响应/只读转换,并在状态关系谱中嵌入原始,非代理的对象

如果把一个嵌套的,没有标记的原始对象设置成一个响应式对象,然后再次访问它,你获取到的是代理的版本,这可能会导致对象身份风险

即执行一个依赖于对象身份的操作,但却同时使用了同一对象的原始版本和代理版本

const foo = markRaw({
  nested: {}
})
const bar = reactive({
  // 尽管 `foo` 被标记为了原始对象，但 foo.nested 却没有
  nested: foo.nested
})
console.log(foo.nested === bar.nested) // false
总结
ref()与reactive()是将一个非响应式类型数据变为响应式数据,而toRaw()与markRaw()相当于是对响应式数据的还原,将一个响应式数据变为非响应式数据

而toRaw只针对响应式对象类型的数据起作用,如果涉及到将一个响应式数据转变为非响应式数据,只用于纯数据的渲染,不引起页面的更新,就可以使用toRaw或markRaw()

往往**可以提升数据的性能**






#### Teleport



------

### 从0到1搭建Vue项目

1. 搭建开发环境（node、vue-cli或vite）
2. 了解项目需求
3. vue create my-app或npm create vite



### 

### vite3创建vue3多环境配置

场景需求：平时业务开发中，在各阶段中都会有不同的运行环境，常用的我们就有开发环境、测试环境、生产环境 ，这就使到我们要对vue3项目做环境拆分

1. 在项目根目录下创建不同的环境变量文件，以便于在项目中引用

<img src="/Users/jiangchuan/Library/Application Support/typora-user-images/image-20221217030606004.png" alt="image-20221217030606004" style="zoom:50%;" />

2. 在文件中写于环境变量

   ```javascript
   ## 开发环境 .env.development
   
   # 变量必须以 VITE_ 为前缀才能暴露给外部读取
   NODE_ENV='development'
   
   VITE_APP_TITLE = 'collect-infor-admin'
   VITE_APP_PORT = 8080
   VITE_APP_BASE_API = '/dev-api'
   VITE_APP_BASE_URL = 'http://127.0.0.1:5000'
   
   
   ## 测试环境	.env.uat
   
   # 变量必须以 VITE_ 为前缀才能暴露给外部读取
   NODE_ENV='uat'
   
   VITE_APP_TITLE = 'collect-infor-admin'
   VITE_APP_PORT = 8090
   VITE_APP_BASE_API = '/uat-api'
   VITE_APP_BASE_URL = 'http://127.0.0.1:5000'
   
   
   ## 生产环境	.env.production
   NODE_ENV='production'
   
   VITE_APP_TITLE = 'collect-infor-admin'
   VITE_APP_PORT = 80
   VITE_APP_BASE_API = '/prod-api'
   VITE_APP_BASE_URL = 'http://10.0.12.8:9500'
   ```

   

3. 配置vite.config.ts文件

   ```javascript
   import { fileURLToPath, URL } from 'node:url'
   import { defineConfig, loadEnv } from 'vite'
   import vue from '@vitejs/plugin-vue'
   
   // https://vitejs.dev/config/
   export default defineConfig(({mode}) => {
     const env = loadEnv(mode, process.cwd(), '')
     return {
       plugins: [vue()],
       resolve: {
         alias: {
           '@': fileURLToPath(new URL('./src', import.meta.url)),
           'pub': fileURLToPath(new URL('./public', import.meta.url))
         }
       },
       // baseUrl: process.env.NODE_ENV === 'production' ? './' : '/',
       // 本地反向代理解决浏览器跨域限制
       server: {
         host: '127.0.0.1',
         port: Number(env.VITE_APP_PORT),
         open: true, // 运行自动打开浏览器
         proxy: {
           [env.VITE_APP_BASE_API]: {
             target: env.VITE_APP_BASE_URL,
             changeOrigin: true,
             rewrite: path =>
               path.replace(new RegExp('^' + env.VITE_APP_BASE_API), '')
           }
         }
       },
       // 打包时去掉项目中的消息打印和断点
       // build: {
       //   terserOptions: {
       //     compress: {
       //       drop_console: true,
       //       drop_debugger: true
       //     }
       //   }
       // }
     }
   })
   
   ```

   

4. 配置axios请求中的baseURL

   ```javascript
   //utils/request.ts
   import axios from "axios";
   
   const service = axios.create({
       baseURL: import.meta.env.VITE_APP_BASE_API,
       timeout: 5000,
       headers: { 'Content-Type': 'application/json;charset=utf-8' }
   })
   
   service.interceptors.request.use(config => {
   ...
   ```

   

### vite

我们知道 `postcss` 可以对某些 `css` 属性（比如 `user-select`）自动添加浏览器前缀。那么 `Vite` 会自动帮我们添加浏览器前缀吗？我们来测试一下，在 `src/css/title.less` 文件中添加 `user-select: none;` 这行代码：

```
@fontSize: ``30px``;``@fontColor: yellow;``.title {`` ``font-size``: @fontSize;`` ``color``: @fontColor;`` ``user-select: ``none``; // 添加 user-select 属性，测试浏览器前缀是否有添加``}
```

然后我们看下浏览器中的效果：

![img](https://img.jbzj.com/file_images/article/202207/20220706083939031.png)

可见，`Vite` 默认情况下是不会帮我们给 `css` 属性添加浏览器前缀的。那如果我们想让它帮我们自动添加该怎么做呢？那么，我们可以先来安装一下 `postcss` 工具：

```
npm ``install` `postcss -D
```

安装完 `postcss` 后，再来执行 `npx vite` 把项目跑起来，再来看效果：

![img](https://img.jbzj.com/file_images/article/202207/20220706083939032.png)

还是没有效果，这是为什么？因为我们说过，`postcss` 是需要依赖对应的插件来帮助我们实现对应的功能的，所以，我们这里可以安装一下 `postcss-preset-env` 插件（或者 `autoprefixer` 插件，但现在 `postcss-preset-env` 用得更多）：

```
npm ``install` `postcss-preset-``env` `-D
```

安装好之后，还需要配置 `postcss`，我们可以在项目目录下新建 `postcss.config.js` 文件，内容如下：

```
module.exports = {`` ``plugins: [``  ``require(``'postcss-preset-env'``)`` ``]``}
```

注意：在使用 `Webpack` 时 `postcss` 配置插件这边可以直接传入字符串，但 `Vite` 这边不行，如果不通过 `require()` 导入插件，而是直接传字符串：

```
module.exports = {`` ``plugins: [``  ``'postcss-preset-env'`` ``]``}
```

启动项目会报错：

![img](https://img.jbzj.com/file_images/article/202207/20220706083939033.png)

然后再来执行 `npx vite` 命令启动项目，浏览器中查看效果：

![img](https://img.jbzj.com/file_images/article/202207/20220706083939034.png)

可以看到，这次就有加上浏览器前缀了。





## Python基础

### 元组

### 字典

### Class 类

### 面向对象

## Python 进阶





```javascript
 "dev": "vite preview --mode development",
 "build": "run-p type-check build-only --mode development",
 "build:p": "run-p type-check build-only --mode production",
 "build:t": "run-p type-check build-only --mode text",
 "preview": "vite preview",
 "build-only": "vite build",
 "type-check": "vue-tsc --noEmit"
```



## Python flask



### 变量规则



```python
from markupsafe import escape

@app.route('/user/<username>')
def show_user_profile(username):
    # 显示该用户的用户个人资料
    return f'User {escape(username)}'

@app.route('/post/<int:post_id>')
def show_post(post_id):
    # 显示给定id的帖子，id是一个整数
    return f'Post {post_id}'

@app.route('/path/<path:subpath>')
def show_subpath(subpath):
    # 在 /path/ 之后显示子路径
    return f'Subpath {escape(subpath)}'
```



### http方法

```python
#	默认路由仅响应 GET 请求。可以使用 route() 装饰器的方法参数来处理不同的 HTTP 方法

from flask import request

@app.route('/login',methods=['GET','POST'])
def login():
    if request.method == 'POST':
        return do_the_login()
    else:
        return show_the_login_form()
#	您还可以将不同方法的视图分成不同的函数。Flask 为每个常见的 HTTP 方法提供了一种快捷方式，用于使用 get()、post() 等来装饰此类路由

@app.get('/login')
def login_get():
    return show_the_login_form()

@app.post('/login')
def login_post():
    return do_the_login()
```





















## Mysql

### mysql连接2059

报错原因是caching_sha2_password不能加载。

这是因为8.0之后mysql更改了密码的加密规则，而目前已有的客户端连接软件还不支持Mysql8新增加的加密方式caching_sha2_password，所以我们需要修改用户的加密方式，将其改为老的加密验证方式。



<img src="/Users/jiangchuan/Library/Application Support/typora-user-images/image-20221219073855531.png" alt="image-20221219073855531" style="zoom:33%;" />



1. 打开终端

2. 登陆数据库：输入mysql -uroot -p

3. 输入你的数据库密码，正确后显示登陆成功 出现Welcome to the MySQL monitor.

4. 输入use mysql; 出现Database changed

5. 输入select user,host from user; 目的为了查看user的root 对应host是什么 我的对应为localhost

6. 输入alter user root@localhost identified by 'password' password expire never;来修改加密规则。

7. 修改加密规则：输入ALTER USER ‘root’@‘localhost’ IDENTIFIED WITH mysql_native_password BY ‘root’;

   注:第一个root为数据库用户名 第二个root为数据库密码 切记换成自己的用户名和密码

8. 如果你查看到的root对应的host为% ，将该句改成ALTER USER ‘root’@‘%’ IDENTIFIED WITH mysql_native_password BY ‘root’;

9.	输入flush privileges，刷新数据库

10. 点击连接测试，或者双击Navicat对应的MySQL即可成功

    <img src="/Users/jiangchuan/Library/Application Support/typora-user-images/image-20221219075709677.png" alt="image-20221219075709677" style="zoom:50%;" />

<img src="/Users/jiangchuan/Library/Application Support/typora-user-images/image-20221219075146583.png" alt="image-20221219075146583" style="zoom:50%;" />













## Linix

> 规划Linux用户目录结构

```shell
├── bin
├── boot
├── home
├── ...
└── root
    └── project
    		├── vue_blogs
        │	  └── nginx
        ├── vue_admin
        │	  └── nginx
        ├── python_blogs
        │	  ├── redis
        │   └── mysql
        ├── python_admin
        │	  ├── redis
        │   └── mysql
        ├── java_admin
        │	  ├── redis
        │   └── mysql
        ├── react
        └── app
```



## docker

### 部署Nginx服务

> 准备工作

准备好静态html文件。如vue、react等项目打包后的文件

1. 创建挂载目录

   使用shell等工具连接到linux服务器。

   ```shell
   # 目录结构
   └── root
       └── vue_admin
       	 └── nginx
              ├── html
              └── conf
   
   ssh root@ 192.168.*.*
   password:****
   cd /root
   mkdir vue_admin
   cd vue_admin
   mkdir nginx
   cd nginx
   mkidr html
   mkdir conf
   
   docker search nginx # 查找nginx镜像
   docker pull nginx    # 下载nginx镜像
   docker images     # 查看下载的镜像中是否有nginx
   ```

   <img src="/Users/jiangchuan/Library/Application Support/typora-user-images/image-20221216011905380.png" alt="image-20221216011905380" style="zoom:50%;" />

2. 创建一个临时nginx容器，复制出它的配置文件和目录结构

   ```shell
   docker run -d --name nginx2 nginx
   docker ps -a
   docker cp nginx2:/etc/nginx/nginx.conf /root/vue_admin/nginx/conf
   docker cp nginx2:/etc/nginx/conf.d /root/vue_admin/nginx
   # 有可能复制后在目录中找不到这俩文件，但是过段时间后又出现了（linux执行copy也这么慢吗）
   docker stop nginx2
   docker rm nginx2
   # 文件复制好后，停掉这个nginx容器，然后删除掉它，
   ```

   

   ![image-20221216014824288](/Users/jiangchuan/Library/Application Support/typora-user-images/image-20221216014824288.png)

   ![image-20221216015019115](/Users/jiangchuan/Library/Application Support/typora-user-images/image-20221216015019115.png)

   <img src="/Users/jiangchuan/Library/Application Support/typora-user-images/image-20221216022340148.png" alt="image-20221216022340148" style="zoom:50%;" />

   

   

3. 根据配置好的目录和文件，创建Nginx容器

   ```shell
   docker run --name vue_admin -p 8101:80 -d -v /root/vue_admin/nginx/html:/usr/share/nginx/html -v /root/vue_admin/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /root/vue_admin/nginx/conf/conf.d:/etc/nginx/conf.d  nginx
   #	-d ：使容器在后台运行
   #	-p ：端口映射，即访问本机的前者(8101)相当于访问docker容器中的后者(80)
   # -v ：将nginx的nginx.conf和conf.d分别挂载到宿主机目录上【特别要注意，如果宿主机上没有这些目录或名字写错或文件弄错，就会创建失败会疯狂报错并启动失败，只能删掉重建】
   
   Error response from daemon: oci runtime error: container_linux.go:290: starting container process caused "container init exited prematurely".
   
   Error response from daemon: oci runtime error: container_linux.go:290: starting container process caused "container init exited prematurely"
   Error: failed to start containers: vue_admin
   
   # 创建容器成功后，以后要修改Nginx配置项，只要去宿主机root/vue_admin/nginx/conf里边的文件就可以了
   
   docker exec vue_admin nginx -t	# 测试配置文件
   docker exec vue_admin nginx -s reload		# 重新加载配置文件
   ```

   ![image-20221216022506387](/Users/jiangchuan/Library/Application Support/typora-user-images/image-20221216022506387.png)

   

4. 服务器防火墙开启Nginx映射的端口8101

   ![image-20221216023520132](/Users/jiangchuan/Library/Application Support/typora-user-images/image-20221216023520132.png)

   > 此时就可以去浏览器输入：公网IP:8101，就可以访问Nginx窗口啦

   ![image-20221216023854701](/Users/jiangchuan/Library/Application Support/typora-user-images/image-20221216023854701.png)

   

5. 配置Nginx服务

   此时只是能访问静态文件，但是接口服务没有作代理，还是会报404错误，因此，我们还要对/root/vue_admin/nginx/conf目录下的文件进行配置。

   <img src="/Users/jiangchuan/Library/Application Support/typora-user-images/image-20221216024443396.png" alt="image-20221216024443396" style="zoom:50%;" />

   

   配置文件有2种方法，一是通过shell工具直接在线操作服务器上的文件；二是将文件下载到本地，配置好后上传覆盖

   这里我使用第二种方法，以下贴出详细文件配置项

### 部署Python服务

1. 创建docker容器

   ```shell
   docker run -it -d --name=py_dome -p 9600:5000 -v /root/python/demo:/root/project --net mynet --ip 172.18.0.3 python:3.9.6 bash
   docker exec -it py_dome bash
   pip install flask -i https://pypi.tuna.tsinghua.edu.cn/simple
   ```

2. 创建环境依赖文件

   ```
   pip freeze > requirements.txt
   ```

   

3. 将Python文件打包成.pyc文件

   ```shell
   python3 -m compileall -b /Users/myMacbook/work/build/flask-dome
   # app.run(host='0.0.0.0')
   ```

   > -m: 当前目录下所有文件
   > -b: 编译后的文件放在当前目录下

4. 主目录下创建Dockerfile文件

   ```shell
   	FROM python:3.9.6      # 基础镜像-python的版本
   	WORKDIR /usr/src/app	# 工作路径
   	COPY requirements.txt ./	# 复制文件到容器中
   	RUN pip install --no-cache-dir -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple # 下载依赖包
   	COPY . .
   	CMD [ "python", "./app.py" ]   # 启动容器时自动执行的命令，我的flask启动命令写在app.py函数里，所以这里我直接去运行此文件 使容器一运行我的flask项目也开始运行
   ```

5. 打包docker镜像文件，创建docker容器并运行镜像文件

   ```shell
   docker build -t flaskdemo . 
   #	-t ：指定要创建的目标镜像名
   #	. ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径
   docker run -d -p 127.0.0.1:6200:5000 --name mydemo1 flaskdemo
   #	-d ：使容器在后台运行
   #	-p ：端口映射，即访问本机的前者(6200)相当于访问docker容器中的后者(5000)
   curl 127.0.0.1:9500
   nohup python app.py > los.txt
   # 启动python程序后仍不能访问请检查下面条件
   app.run(host='0.0.0.0')
   ```

   
